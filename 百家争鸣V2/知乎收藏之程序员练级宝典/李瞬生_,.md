# 李瞬生_,

国外知名 IT 企业是如何做测试的？

李瞬生

,

不经寒彻骨 焉得梅花香

我在微软和亚马逊上过班。就这两个公司谈谈我的经验。

微软作为第一家纯软件公司，有非常完整和传统的开发流程。需求分析、设计、实现、测试、部署、运维每一个阶段都有明确分工。途中有Manager, leader, SDE, SDET 等完成。这样做的好处是各司其职，大家都只需要操心分内的事情。缺点是开发周期较长。

这种工作模式下的测试人员是专职测试，有足够的精力和动机把测试做得很到位。特例总是找得到，但个人经验是SDET对产品质量是有明显的促进作用的。同时SDE和SDET的分工配合，减少了开发者的心理负担。因为需要操心的任务数量减少了。从人道主义的角度是非常不错的。

弊端也很明显，那就是成本。资本家的目的就是收割剩余价值，因此恨不得让你把操心所有事都操心完。因为我对股东没有忠诚度，所以只要允许，我一定会想要SDET在队伍里的。SDE是矛，SDET是盾，一攻一防，各有所长。

亚马逊作为新兴互联网公司，没有那么久的传统，大家多少都还有一些摸着石头过河的感觉。亚马逊这类的互联网公司，更倾向于所谓的敏捷开发还有continuous deployment。特点就是从设计一直到部署运维都由个人负责。Agile开发的假设条件之一就是每一个组员都是full stack developer，全程都可以做。这样做的好处是，开发周期短，bug和新feature可以最快推到prod。缺点是员工的注意力分散。

这种工作模式下，unit/integ test都由搞开发的SDE亲自写。就好比自攻自防一样。个人经验是，这种工作方式十分灵活，可以跳过测试直接prod。也可以几周时间专门做测试。但一个趋势是SDE潜意识会削减测试的时间，在出事故过后又花过多的时间补测试。另外，我个人的经验是，抠门到不请SDET的公司，通常也不会慷慨到雇专门的运维。这样做是可以省成本，但也大大加重了员工的身心负担。

最后，一些软件部署周期本来就长（如Photoshop/Visual Studio这样的桌面商业软件），长时间不会有用户反馈。个人认为实践上不可能不用专职SDET。即使在亚马逊，一些特定的部门因为产品性质，还是会有专职测试。那样的产品通常fix bug的成本很高。

因此说白了，专职Test的重要性还是由产品性质和预算成本来决定的。微软有钱烧，大部分组都有专职test。亚马逊是出了名的血汗码农场，别说专职test，连运维都要dev上。

赞同：205

评论：38

怎样才能加入到微信团队工作？

杨平安

,

没有调查没有发言权

首先恭喜题主，当你提出这个问题，表达到微信团队工作意愿时候，就已经跨越了最艰难的一步。不会说接下来就是轻松坦途，但你已经找到最核心的东西。像路飞、像鸣人，无论大航海还是修炼，拚了命也要守护的东西，在第一集里就已经大声喊出来。题主既然自言热血，热血的人需要意义活着，如有意义，其后的实现，如何艰辛挫败，都能咬牙忍着。不关怀意义，而着重手段的，都是凡人，无人为凡人立碑。

再来个身边的励志故事，在一年前我入职那会，腾讯北京分部，有位物业的保安同学，经过流程面试，顺利转岗到程序运营职位，听说近来已经成了leader。后来更详细情报显示他原来是洛阳大学毕业，当年非要到腾讯工作，因为没有面上，于是曲线加入到保安，一直没有放弃。旁观者在乎的是这个过程，认为是段传奇。而他本人，我认为，更感激的应该是那个初心。

如上是题外话，不干问答，但如对题主能稍有鼓舞，也算寸心。

下面回答正经的。

微信团队有许多岗位，因为现在势头如火如荼，也是求贤纳才，如饥似渴，如果题主现在来应职，可谓正当其时。因为我在后台中心工作，对这方面更熟悉一些，只回答：

“怎样才能加入到微信团队后台中心工作？”

不知道题主有无关注过“腾讯广州

职位

招聘”，里面许多关于后台开发的岗位，都有列出工作要求，每条看下来其实大同小异，无外乎如下：

1. 精通C/C++编程语言－－这是硬性标准，不单微信，不单腾讯，在国内各大公司的后台岗位，C\C++可算求职应聘、安身立业的必备利器.

2. 精通基础数据结构，基本算法－－起码你得把《数据结构》、《算法导论》看的滚熟吧.

3. 熟练掌握Linux\Unix开发－－APUE你翻完了吗？.

如上三条，简而言之，就是会写代码。能视代码如美玉，玩代码于股掌。只要你能，其余不看脸蛋，休谈背景。基础平台组、功能开发组、系统架构组等等，总有一款合适你。

如果题主检讨自己发现这些要求不过儿科，那切莫犹豫，急急发送简历到：armyoung@qq.com。当天没能联系你，你屌我。

再说些写题外的话：

“为什么要加入到微信工作？”

首先我要说的是意义。当时乔布斯鼓动百事总裁到苹果工作时，说了句著名的话：你是想一辈子卖甜糖水，还是要改变世界。这句话刚听时还眼前一亮，亮久了可能就有人被闪瞎，觉着改变世界神马的说法太装。这难怪，齐家治国平天下，逐次下来，其身未善的人很难有后面的眼光。你能想象吗？它不但传播话题，本身也是话题。你在微信工作的每个参与，都能勾引起轩然大波，以知乎为例：

微信 5.0.3 版本的『标为未读』功能是照顾到用户什么心理？

微信 5.0 新版设计是否不注重细节？

微信 4.5 版，为什么把「实时对讲机」作为重要更新功能进行推荐？它是大多数用户需要的功能吗？

这些只是随手翻来一些。作为微信员工，当你浏览这些时，无论批评还是赞扬，你都能想到：哦，他们在讨论我们的产品。

成就感是最直接的奖励。你在公交上，你去旅游时，陌生人、老朋友，甚至洗头房的从业人员，你听到熟悉的叮声，你清楚，TA也在用自己的产品，不需要说出来博异样，心里还是满足的。

还会有年末回家，看到老爸老妈也在试着用自己工作的结晶与人沟通更快意的吗？

如何看待现在很多大叔大妈都使用微信这个现象？

微信在伊朗是被屏蔽的，因为威胁了他们的国家安全。微信差点在越南也被拉黑，因为抢了他们运营商的饭碗。每周五中午微信海外发信数量总会下跌，查找出来是因为穆斯林中午要作礼拜。你去泰国旅游，搜索附近的人，太漂亮的头像不要点，可能是人妖，其余选择还是很多的。

再次是认同，你是否被微信的启动页面触动过，你可听过那首完整的一无所有，满屏燃烧的大火可片刻灼烧了你。这些不是无用功，表现出来的是认同，没说出来的是情怀。正因有此，微信已经超越工具，是一种生活方式。感性的人莫发愁，这里无关铜臭。

http://zhi.hu/L7zi

http://zhi.hu/XSuY

http://zhi.hu/FqzA

再说些真金白银实在的，工作环境，大家可以点击

在腾讯广州研究院工作的感觉如何？可以接触到哪些产品?

微信团队土豪新家首度曝光

延伸一下，下面是对技术达人说明的：

“为什么要加入到微信后台工作？”

先问一个问题，你持有何种观点：

从技术层面看，从客观现实出发，12306逢节必瘫情有可原吗？

如果你觉着那必然万不可恕，那不错，我们还有共同语言。

在微信后台分分种千万上下，成亿消息游走，不是稀罕事。12306那种数量级算事吗？答主服务的东东，千亿级别的key，随便的各处流动，我会到处讲？

来吧，来吧，在微信后台，“你可以学习：一个高性能的RPC框架如何实现，什么才是RPC框架中的最重要的部分.我们如何实现可靠的监控与报警系统，帮助快速发现与解决异常问题.我们如何对服务进行单元化管理，做到柔性可用等等。在业务上，你可以学习：如何实现超过一亿长连接的pub/sub接入系统，如何实现只需三台存储便能支撑数亿用户的序列号分配器，如何实现稳定的亿级苹果push推送机制，如何实现日启动数亿次的摇一摇与解决附近的人位置计算问题等等。”[引自：

https://groups.google.com/forum/#!topic/pongba/8zpfCO1-JBg

]

如果没有激情，我会周日到公司加班来写这么多？！

好，以上。走过路过不要错过，如你有意，armyoung@qq.com。我必回情。

拉几个大牛来撑场面。

@ponyma

@allenzhang

你们怎么看？

赞同：196

评论：50

初学 Python，有哪些 Pythonic 的源码推荐阅读？

赖勇浩

,

喜欢编程的家伙，完成了 game -> webgame -> web 的转变。

谢邀。看到邀请已经很久了，一直没敢回答，主要是我自己没有读过多少模块的源码，因为我一直认为读源码是一种比较“低效”的学习方法。我用 yolk -al 看了一下安装的模块，发现居然也没有几个算是“读过”的。web.py 的读过一点，它的接口很 pythonic，但这货的实现应该算不上是非常 pythonic 的代码。

如果一定要推荐一些 python 的源码去读，我的建议是标准库里关于网络的代码。从 SocketServer 开始，补上 socket 模块的知识，熟悉 TCP/UDP 编程，然后了解 Mixin 机制的最佳示例 SocketServer.{ForkingMixIn|ThreadingMixIn}，借这个机会了解 thread/threading 模块，这时会对并发量提出新的要求，就可以读 select 模块，开始对 select/{epoll|kqueue} 有深刻理解，搞懂以后就可以接触一下异步框架 asyncore 和 asynchat。这时开始出现分岔。如果是做 game 等以 TCP/UDP 协议为基础的应用，可以去读 greenlet 和 gevent，如果是做 web，则走下一条路。

做 web，读 BaseHTTPServer、SimpleHTTPServer 和 CGIHTTPServer，读 cgi/cgitb，自己随意写框架，读cookielib，读 wsgiref，这时候自己写一个简便的 web framework 就 so easy 了，老板再也不担心你写 web 了，选择 flask/web.py/django/pyramid 都心中有数了。因为走的是 web 的路，所以难免要调用一下别人的 api，搞懂一下 httplib/urllib/urllib/urlparse。

最后，上述提到的标准库，我大多读过。

赞同：186

评论：8

如何更有效地学习开源项目的代码？

庄表伟

,

略懂一些

推荐深入阅读一篇正在写作中的文档：借助开源项目，学习软件开发。

http://sbbs.me/view_article/50606ecb08158efb55000009

说说我的开源学习经历：

1、下载源代码之后，首先要跑起来。编译通过、正常运行。

2、在你觉得最有可能的运行到的地方，设置断点或者抛出异常，这样，就能够找到一个项目在正常运行时的入口点。

3、从入口点所在的那个源文件开始阅读，逐步把握整个项目是如何启动起来的。

4、随便改点代码，看看会不会报错，如果报错，会从哪里报错。

5、试着把报错屏蔽、修复、或者绕开。

6、尝试理解一个系统的内部结构，多少组成部分，主线模块是哪些？辅助模块是哪些？

7、从实际需要出发，修改这个项目，满足自己的某一个小的需求。

在此之前，尽量不要在网络上找答案。

8、看看相关的讨论与心得，看看是否与自己的理解相一致。

9、提交bug fix或者某个新的功能代码。

在学习开源的过程中，有几个方面，会获得大量的收获：

1、架构与模式

2、开源社区常见的一些惯用法

3、相关领域的结构与算法

总结一点是：学习开源，就尽可能在代码里找答案，而不是在代码之外找答案，那些都是二手的，而且很可能是不准确的。

赞同：184

评论：7

为什么多 TCP 连接分块下载比单连接下载快？

马嘉男

简短版本：

TCP特性使得每个TCP连接可以得到均等的带宽。在多用户环境下，一个用户拥有越多TCP连接，获得的带宽越大。

具体来说：

这个涉及到了TCP的拥塞控制。

我们先看一下单TCP连接的拥塞控制。

这是一个TCP连接的发送窗口。

绿色部分为发送者已发送，且接收者已确认（ACKed）。

黄色部分为发送者已发送，但接收者尚未确认（"in-flight"）。

蓝色部分为可用但尚未发送。

灰色部分为不可用。

所以在RTT（round-trip time，来回通讯延迟）不变的情况下，cwnd这个变量基本决定传输速率。

发送者总会试图找到不丢包情况下的最大速率。按照TCP协议，在传输开始之后，每接收到一个确认（ACK)就会把cwnd这个变量增大一倍。所以TCP连接开始之后应该是这个样子。

刚开始的时候传输速率应该是指数被增长的，直到丢包发生。丢包会有两种情况：

1.当接收者发送给发送者的ACK丢失了，这时会触发超时（timeout)。

2.当发送者发送给接收者的数据包丢失了，发送者会收到接收者发来的重复ACK，如果发送者收到了3个重复的ACK，也会认为发生了丢包。

具体对这两种情况采取的措施略有不同，但粗略来说，变量cwnd会被减半，也就是说传输速率减半。然后cwnd会再次增大，直到下次丢包发生。所以忽略最开始，TCP的吞吐量应该是这样。

好，那么现在我们来看多TCP连接的拥塞控制。

我们假设有两条同样的TCP连接。在他们的连接中间有一个共用的瓶颈路由器，带宽为R。

假设这两条连接都需要传输足够大量的数据，那么不论他们谁先开始传输，最后一定会均分带宽。

因为如果总传输速率低于R的时候就会不断增大传输速率，某个连接在增大传输速率的时候发生丢包就会减半传输速率，最后趋于平衡。

所以k条经过同一节点TCP连接会平分带宽R，每条连接得到带宽R/k。

正因为如此，不论是以前的net vampire，还是现在的迅雷都采取增加并发连接数的方法来加快下载速度。

references:

James F. Kurose, Keith W. Ross:

Computer Networking: A Top-Down Approach

, 6e

赞同：182

评论：21

虚拟机是怎么实现的？

高鹏

,

OS Kernel / Virtualization / Storage

问题有点大，笼统的试答一下。坑比较深，最好有基本的OS基础才好理解。

假设这里的虚拟化是指在一个OS下虚拟化另外一个OS（ESX那种hypervisor直接跑在硬件上的做法，其实大同小异），另外假设这里的虚拟化是指full virtualization而不是Xen那种para-virtualization。最后假设虚拟化的是一个早期的x86机子（没有hardware supported virtualization的存在）。

要回答这个问题，首先看为什么一个OS无法直接与另外的OS共存。答案很简单，OS作为硬件上第一层软件，认为自己拥有全部的硬件的访问和控制权，且自己是唯一的控制者。在这种情况下，如果两个OS共存，必然产生问题。

OS主要负责管理的是CPU和内存，以及众多的IO设备。于是我们可以分别讨论。hypervisor是实现虚拟化的关键，它会以一个内核态的驱动存在。

CPU的虚拟化：

背景知识：x86 CPU有一项权限机制，把CPU的状态置于RING 0到RING 3分别使CPU具有最高的权限到最低的权限。以Linux为例，内核运行于RING 0上，而其余全部用户进程运行于RING 3上（Xen比较奇葩，Linux在Xen下面会运行于RING 1）。在用户权限下，所有的IO设备是不可操作的，另外，有些控制寄存寄是无法访问的，一些privilege的指令是不能运行的。因此一个用户进程要想读写文件，进行一些操作，就要依赖于内核。系统调用能够使CPU运行于RING 0，并执行内核代码（具体方法见一些操作系统教程）。

背景说完。一个CPU的全部状态其实就是所有寄存器的值，只要保证任何操作之后寄存寄的值在OS看来是正确的，guest OS就可以正常执行。hypervisor会为每个虚拟的CPU创建一个数据结构，模拟CPU的全部寄存器的值，在适当的时候跟踪并修改这些值。

那么考虑虚拟化一个CPU，在虚拟化的guest OS里面，CPU无论如何也不可能运行于RING 0，因为这样的话，host OS必然会crash掉。因此，当一个guest OS想要进入到RING 0执行内核代码时，hypervisor会向guest OS说谎，并告诉它，你已经在RING 0上了，而实际上，所有的指令还是在RING 3上。当guest OS访问到任何privilege的东西时，hypervisor会接到fault，此时hypervisor会判断这个指令是什么，并修改相应的虚拟寄存器的状态，然后返回。这样guest OS就可以正常的运行。需要指出的是，在大多数的指令下代码是直接跑在硬件上的，而不需要软件介入。只有在一些权限高的请求下，软件会介入，并维护虚拟的CPU状态。

内存的虚拟化：

背景知识：虚拟内存，页表结构等。OS的基础内容，不表。

hypervisor虚拟化内存的方法是创建一个shadow page table。正常的情况下，一个page table可以用来实现从虚拟内存到物理内存的翻译。在虚拟化的情况下，由于所谓的物理内存仍然是虚拟的，因此shadow page table就要做到：虚拟内存->虚拟的物理内存->真正的物理内存。

以下是细节，如果看着闹心，请忽略。hypervisor会维护一个从虚拟内存到物理内存的映射，当guest OS更换自己的page table，也就是改变CR3寄存器的值，hypervisor会因为用户态的权限不足而接到一个general exception，hypervisor会记录用户想要更换的新的页表，并放上一个空的shadow page table，然后返回。这个空的shadow page table会在接下来的执行中造成CPU无法进行地址翻译，而产生page fault。在fault发生后，hypervisor会得到一个虚拟地址，然后根据之前记录的用户的页表结构，翻译出一个虚拟机器地址，然后再把这个虚拟的机器地址，由hypervisor维护的映射翻译为实际的机器地址，然后装入shadow page table，并返回执行。如此，就实现了：虚拟内存->虚拟的物理内存->真正的物理内存。

I/O虚拟化：

背景知识：memory mapped I/O device。大多数的PCI设备都是直接将自己的某些控制寄存器映射到物理内存空间上，CPU访问这些控制寄存器的方法和访问内存相同。CPU通过修改和读取这些寄存器来操作I/O设备。

虚拟化的方法很简单，没当hypervisor接到page fault，并发现实际上虚拟的物理内存地址对应的是一个I/O设备，hypervisor就用软件模拟这个设备的工作情况，并返回。比如当CPU想要写磁盘时，hypervisor就把相应的东西写到一个host OS的文件上，这个文件实际上就模拟了虚拟的磁盘。

这里忽略了很多异常处理等等细节，但求简化，可是貌似还是写多了。以上。

赞同：171

评论：21

Dalvik 虚拟机和 Sun JVM 在架构和执行方面有什么本质区别？

天光

,

一檐停风聚天下闲士 半阁藏卷窃古今名家

谢邀，抱歉拖了这么久才回答这个问题。

其实其核心的差异，就是Dalvik 虚拟机架构是 register-based，与 Sun JDK 的 stack-based 不同，也就是架构上的差异。我先摘录几段网上可以找到的资料，重新整理和排版了一下，由于这些资料在网上经过多次转载，转发和加工，原作者不详，所以无法标注其原作者们，如有原作者认领或者质疑，请及时通知我。

其中部分资料为

@RednaxelaFX

所著，特此感谢！

特别提供原文链接：

http://rednaxelafx.iteye.com/blog/492667

(1) Dalvik VM和JVM 的第一个区别是 Dalvik VM是基于寄存器的架构（reg based），而JVM是栈机（stack based）。reg based VM的好处是可以做到更好的提前优化（ahead-of-time optimization）。 另外reg based的VM执行起来更快，但是代价是更大的代码长度。

(2) 另外一个区别是Dalvik可以允许多个instance 运行，也就是说每一个Android 的App是独立跑在一个VM中.这样做的好处是一个App crash只会影响到自身的VM，不会影响到其他。 Dalvik的设计是每一个Dalvik的VM都是Linux下面的一个进程。那么这就需要高效的IPC。另外每一个VM是单独运行的好处还有可以动态active/deactive自己的VM而不会影响到其他VM

(3) 接下来就是关于版权之类争论。（可以参看下面文章）

既然reg based VM有那么多好处，为什么之前设计JAVA的人没有采用reg based而是采用stack based的呢？ 原来stack based的VM也有其优点，就是它不对host平台的reg数量做假设，有利于移植到不同的平台。而Dalvik则不关心这些，因为它本来就是为ARM这样的多reg平台设计的。另外Dalvik被移植到x86也说明，即使是x86这种reg很少的平台，reg based的VM也是没有问题的。

下面着重说下DVM的优势：（部分文字我加黑以突出）

1、在编译时提前优化代码而不是等到运行时

2、 虚拟机很小，使用的空间也小.被设计来满足可高效运行多种虚拟机实例。

3、常量池已被修改为只使用32位的索引，以 简化解释器

JVM 的字节码主要是零地址形式的，概念上说JVM是基于栈的架构。Google Android平台上的应用程序的主要开发语言是Java，通过其中的Dalvik VM来运行Java程序。为了能正确实现语义，Dalvik VM的许多设计都考虑到与JVM的兼容性.但它却采用了基于寄存器的架构，其字节码主要是二地址/三地址的混合形式。

基于栈与基于寄存器的 架构，谁更快？现在实际的处理器，大多都是基于寄存器的架构，从侧面反映出基于寄存器比基于栈的架构更与实际的处理器接近

。但对于VM来说，源架构的求值 栈或者寄存器都可能是用实际机器的内存来模拟的，所以性能特性与实际硬件又有不同。一般认为基于寄存器架构的Dalvik VM比基于栈架构JVM执行效率更高，原因是：虽然零地址指令更紧凑，但完成操作需要更多的load/store指令，也意味着更多的指令分派 （instruction dispatch）次数与内存访问次数.访问内存是执行速度的一个重要瓶颈，二地址或三地址指令虽然每条指令占的空间较多，但总体来说可以用更少的指令完 成操作，指令分派与内存访问次数都较少。

我们从下面的截图可以明了的看到与同一段Java代码对应的Java bytecode 与Dalvid bytecode的比较：

网上一些文章在讨论 Dalvik 时，大都简单提及 Dalvik 执行速度比 JVM 快，但移植性稍差。这里 我们延伸探讨一下。在一个解释器上执行 VM 指令，包含三个步骤，指令分派、访问操作数和执 行计算。 指令分派（Instructions dispatch）负责从内存中读取 VM 指令，然后跳转到相应的解释器代码 指令分派 中。上面提到过，完成同样的事情，基于栈的虚拟机需要更多的指令，意味着更多的指令分派和 内存访问次数，这是 JVM 的执行性能不如 Dalvik VM 的原因之一。

访问操作数 访问操作数（Operands access）是指读取和写回源操作数和目的操作数。Dalvik VM 通过虚拟 操作数 寄存器来访问操作数， 由于具有相近的血缘， Dalvik 的虚拟寄存器在映射到物理寄存器方面具有 更充分的优势， 这也是 Dalvik VM 性能较佳的一个原因。 JVM 的操作数通过操作数栈来访问， 而 因为指令中没有使用任何通用寄存器，在虚拟机的实现中可以比较自由的分配实际机器的寄存 器，因而可移植性高。作为一个优化，操作数栈也可以由编译器映射到物理寄存器上，减少数据 移动的开销。 指令执行（Instructions compute）这个似乎没什么可解释的，老老实实执行就行。 指令执行

一个应用中会定义很多类， 编译完成后即会有很多相应 的CLASS文件，CLASS文件 间会有不少冗余的信息。

dex字节码和标准Java的字节码（Class）在结构上的一个区别是dex字节码将多个文件整合成一个，这样，除了减少整体的文件尺寸，I/O操作，也提高了类的查找速度。

原来每个类文件中的常量池现在由DEX文件中一个常量池来管理。

DEX文件可以进行进一步优化。优化主要是针对以下几个方面：

1、调整所有字段的字节序（LITTLE_ENDIAN）和对齐结构中的没一个域

2、验证DEX文件中的所有类

3、对一些特定的类进行优化，对方法里的操作码进行优化

优化 优化后的文件大小会有所增加，应该是原DEX文件的1-4倍。 odex是为了在运行过程中进一步提高性能，对dex文件的进一步优化

每一个Android应用都运行在一个Dalvik虚拟机实例里，而每一个虚拟机实例都是一个独立的进程空间。每个进程之间可以通信（IPC，Binder机制实现）。虚拟机的线程机制，内存分配和管理，Mutex等等都是依赖底层操作系统而实现的。

不同的应用在不同的进程空间里运行，当一个虚拟机关闭或意外中止时不会对其它虚拟机造成影响，可以最大程度的保护应用的安全和独立运行。

Zygote是虚拟机实例的孵化器。AndroidRuntime.cpp中ZygoteInit.main()的执行会完成一个分裂，分裂出来的子进程继续初始化Java层的架构，这个分裂出来的进程就是system_server。每当系统要求执行一个Android应用程序，Zygote就会FORK出一个子进程来执行该应用程序。这样做的好处显而易见：Zygote进程是在系统启动时产生的，它会完成虚拟机的初始化，库的加载，预置类库的加载和初始化等等操作，而在系统需要一个新的虚拟机实例时，Zygote通过复制自身，最快速的提供个系统。另外，对于一些只读的系统库，所有虚拟机实例都和Zygote共享一块内存区域，大大节省了内存开销。

=============================分割线===========================

下面我以我的认知来简单总结描述一下，DVM和JVM这种架构上的差异所产生的影响

JVM其核心目的，是为了构建一个真正跨OS平台，跨指令集的程序运行环境（VM）。DVM的目的是为了将android OS的本地资源和环境，以一种统一的界面提供给应用程序开发。严格来说，DVM不是真正的VM，它只是开发的时候提供了VM的环境，并不是在运行的时候提供真正的VM容器。这也是为什么JVM必须设计成stack-based的原因。

JVM：所有的jar程序，其运行环境完全是由JVM来提供，包括运行时，各类资源的调度，而JVM的架构，其设计为一个JVM里面可以运行多个java程序，JVM就像一个真正的“机器”，可以跑着多个程序。如果去看看一些企业级的JVM（例如tom cat，WAS），从OS的进程管理中，一般你只能看见一个JVM的进程（当然，你也可以起多个JVM，但JVM架构就是OS-JVM-APP的3层运行时模式），而看不见JVM里面运行的程序，而一个JVM里，可以跑多个java app。简单得说，JVM完全屏蔽了应用程序和OS之间的联系，而改用JVM充当了中间层，这也是一个真正跨平台运行时VM必须要做到的。只要是相同的JDK，JVM为所有在其中运行的程序，提供了完全一致的运行环境，而不论你是什么样的底层OS和硬件条件。因此这也是我在其他一篇答案中提到，JVM的特点是取底层OS和硬件环境的交集，从而保障这种一致性。而所有应用程序和底层资源的互动，一定是依赖JVM的传递和转换来实现。JVM真正实现了一个OS对应用程序运行时管理的所有功能。从开发环境角度和运行时角度，都是完全一致的真正VM

DVM：而DVM的特点在于使用了Zygote，Zygote有几个非常有意思的特点。

一是Zygote采用预加载，由其首先判定安装的APK的需要以及相互依存树，以及OS及硬件环境的特点，在每次启动的时候进行预加载（现在你明白为什么android的app在应用管理里你能轻易查到它都调用了那些关键性的本地资源的原因了吧？），这就意味着，你安装的应用越多，Zygote的加载就越慢，一般来说你的手机启动就会越慢。另外来说，在不同的硬件环境里（例如有无GPS芯片）Zygote初始化的实例是不同的。也就是说，zygote并不提供一个统一的运行环境，具有更好的弹性，这种机制意味着DVM可以取底层资源的合集来提供上层应用使用，差别只是在程序安装或者启动的过程中，DVM可以提示程序需求资源，本地环境可能未能满足而导致无法运行。DVM的Zygote并不是提供一个运行时容器，它提供的只是一个用于共享的进程，所有的应用程序运行，都是独立的，OS级别的进程，直接受到OS层面的资源控制以及调度的影响，只是他们共享Zygote说预加载的类而已。这也就是我为什么说，DVM就像是给每个应用程序在底层加了个套子，而不是提供了一个真正的运行时的VM。也就是说，DVM在开发环境中说提供的VM平台，和运行时的环境是很有可能不一致的。开发环境中提供的VM平台，是一个各种运行时可能环境的合集。

从这点上来说，一般我们认为，JVM中的JAVA程序的崩溃，最多导致JVM的崩溃，而不会导致OS崩溃，但是apk的崩溃，可以直接导致OS崩溃，android手机会因为应用程序死机，大家应该是很常见了。但是大家一般是不会看到java程序导致死机吧？因为运行时中间隔着一个JVM。（当然，其实还是有些小门道可以用java程序让OS崩溃，因为这个，我和某些JAVA大拿打赌赢过饭局，呵呵，不过这是其他话题，不在这里展开了）

除此之外，在JVM的机制中，不同的程序，打包以后，他们都是在运行层级真正独立的程序（指程序应用他们相互之间的关系，而不是和JVM的关系），即便他们在包里使用了同样的类，运行时都是单独加载，单独运行的（及加载多遍）。

DVM这种预加载-共享的机制，使得不同应用之间，在运行时，是共享相同的类的，一般来说，在系统资源消耗方面，拥有更高的效率。

最后，补充一点，byte code并不意味着就是解释执行，也能是加载编译，安装编译，预编译等等。实际上，不同的byte code的程序，不同的技术，不同的具体语言，其真正执行的情况是挺复杂，难以一概而论的，好多都是混合技术的案例，从我对odex的技术来看，就是个典型案例。当然这是题外话，不多展开了

赞同：161

评论：21

常见的网站服务器架构有哪些？

牛浩帆

,

知乎是个理想国

2013/04/18 更新

[只是大框架介绍，实际使用中的不容易注意的细节太多了，需要经验的积累，才能运用娴熟]

以下的架构都是在假设已经优化过linux内核的情况下进行

初级篇：（单机模式）

假设配置：（Dual core 2.0GHz,4GB ram,SSD）

基础框架

：apache(PHP) + Mysql / IIS + MSSQL

（最基础框架，处理一般访问请求）

进阶1

：替换Apache为Nginx，并在数据库前加上cache层【

数据库的速度是最大的瓶颈

】

Nginx(PHP) + Memcache + Mysql

（此时已经具备处理小型访问量的能力）

进阶2

：随着访问量的上涨，最先面临的问题就来了：CGI无法匹配上Nginx的高IO性能，这时候可以通过写扩展来替代脚本程序来提升性能，C扩展是个好办法，但是大家更喜欢用简单的脚本语言完成任务，Taobao团队开源了一个Nginx_lua模块，可以用lua写Nginx扩展，这时候可处理的并发已经超越进阶1 一个档次了。

Nginx(nginx_lua or C) + Memcache + Mysql

（此时处理个同时在线三四千人没有问题了）

进阶3

：随着用户的增多，Mysql的写入速度成了又一大瓶颈，读取有memcache做缓存，但写入是直接面对Mysql，性能受到了很大阻碍，这时候，要在Nginx和Mysql中间加入一层写缓存，队列系统就出场了,就以RabbitMQ为例，所有写入操作全部丢到这只兔子的胃里面，然后屁股后面写个接应程序，一条条的拉出来再写入mysql。而RabbitMQ的写入效率是Mysql的N倍，此时架构的处理能力又上一阶层。

|----write------>RabbitMQ--------

Nginx（lua or c）----- |--------->Mysql

|----read------>Memcache--------

(此时的并发吞吐能力已经可以处理万人左右在线)

中级篇：（分而治之）

此时我们在单机优化上已经算是达到极限，接下来就要集群来显示作用了。

数据库篇：

数据库总是在整个环节中是吞吐能力最弱的，最常见的方法就是sharding。

sharding可以按多种方法来分，没有定式，看情况。可以按用户ID区段分，按读写分等等，可用参考软件：mysql proxy（工作原理类似lvs）

缓存篇：

memcache一般采用的是构建memcache pool，将缓存分散到多台memcache节点上，如何将缓存数据均匀分散在各节点，一般采用将各节点顺序编号，然后hash取余对应到各个节点上去。这样可以做到比较均匀的分散，但是有一个致命点就是，如果节点数增加或减少，将会带来几乎80%的数据迁移，解决方案我们在高级篇再提。

WEB服务器篇：

web服务器集群的建设，最常见的就是lvs方式(memcache pool同样可以如此组建)，lvs的核心就是调度节点，调度节点负责将流量通过算法分散到各个节点上，因调度所耗资源很少，所以可以产生很高的吞吐率，后台节点数量可以任意增删，但此法弊病就是如果调度节点挂了，则整个集群都挂了，解决方案我们在高级篇提。

方法2:参见

HAProxy - The Reliable, High Performance TCP/HTTP Load Balancer

高级篇：（高可用性+高可扩展性的集群）

单点调度故障解决：

集群的好处显而易见，但是有一个弊端就是单节点进行调度，如果节点出现故障，则整个集群全部都无法服务，对此的解决方案，我们使用

keepalived

来解决。

Keepalived for Linux

keepalived是基于VRRP协议（

VRRP协议介绍

）的，请一定先了解VRRP协议后再进行配置。

keepalived可以把多台设备虚拟出一个IP，并自动在故障节点与备用节点之间实现failover切换。这样我们配置两台货多台lvs调度节点，然后配置好keepalived就可以做到lvs调度节点出现故障后，自动切换到备用调度节点。（同样适用于mysql）

memcache集群扩展解决：

memcache因为我们一般采用的都是hash后除以节点数取余，然后分配到对应节点上，如果节点数出现变化，以前的缓存数据将基本都不能命中。

解决方法：consistent hashing 简介：

一致性哈希

consistent hashing大概的思路就是，把hash后的值保证在 0 ~ (2^32)-1 的数值上，然后把这一连串数字对应映射到一个想象的圆上。

把要存储的各个值hash后，放到圆上，如图

然后把cache节点也用同样的hash方法，映射到圆上，然后每个刚才hash过的value顺时针寻找离自己最近的节点，这个节点就是存储它的节点。

为了提高存储的平衡性，算法还可以加入虚拟节点的概念，即每个实际cache节点，会在圆上对应N个虚拟的节点，这样可以提高算法的命中率，更加平衡。

consistent hashing原理：

Consistent hashing and random trees

完结。

另：以上图片来自互联网，未找到原创者，故未标注来源。

欢迎署名转载。

赞同：161

评论：14

淘宝的评论归纳是如何做到的？

ZBBBB

,

在互联网里打滚

PS：语义分析的概要过程大家可以去程序员杂志七月刊上阅读

作为这个产品技术团队之一，简单说下这个过程：

1，按类目特征，拉取这个类目下的评论，进行分词，统计词频.

2，对词进行聚类，包含常用的LDA，结合本体库，将词进行归类和分类，建立语料库.（分类是最重要的一步，比如服装类目下学院风、淑女、熟女、休闲等都会归为款式这类）

3，属性情感搭配，建立属性词和情感词的连接关系，判断分句的情感.

4，属性词+情感词转换到属性类的情感，对句子进行位置标记.

5，将属性情感和位置标记结果build到搜索中，便于根据标签反向检索内容。

借用一句话：产品从0到1是很容易的，但是将1做到100确实个不断优化的过程，期待对这方面有兴趣的人给予建议和指导，也大大欢迎加入共建。

赞同：157

评论：21

Leap Motion 的原理是什么？

匿名用户

從 API 的角度大概說一下。

Leap Motion 傳感器的結構：

大體上，Leap 傳感器根據內置的兩個攝像頭從不同角度捕捉的畫面，重建出手掌在真實世界三維空間的運動信息。檢測的範圍大體在傳感器上方 25 毫米到 600 毫米之間，檢測的空間大體是一個倒四棱錐體。

首先，Leap Motion 傳感器會建立一個直角座標系，座標的原點是傳感器的中心，座標的 X 軸平行於傳感器，指向屏幕右方。Y 軸指向上方。Z 軸指向背離屏幕的方向。單位爲真實世界的毫米。如圖：

在使用過程中， Leap Motion 傳感器會定期的發送關於手的運動信息，每份這樣的信息稱爲「幀」( frame )。每一個這樣的幀包含檢測到的：

所有手掌的列表及信息.

所有手指的列表及信息.

手持工具（細的、筆直的、比手指長的東西，例如一枝筆）的列表及信息.

所有可指向對象（Pointable Object），即所有手指和工具的列表及信息.

Leap 傳感器會給所有這些分配一個唯一標識（ID），在手掌、手指、工具保持在視野範圍內時，是不會改變的。根據這些 ID，可以通過 Frame::hand( ) , Frame::finger( ) 等函數來查詢每個運動對象的信息。

Leap 可以根據每幀和前幀檢測到的數據，生成運動信息。例如，若檢測到兩隻手，並且兩隻手都超一個方向移動，就認爲是平移.若是像握着球一樣轉動，則記爲旋轉。若兩隻手靠近或分開，則記爲縮放。所生成的數據包含：

旋轉的軸向向量.

旋轉的角度（順時針爲正）.

描述旋轉的矩陣.

縮放因子.

平移向量.

對於每隻手，可以檢測到如下信息：

手掌中心的位置（三維向量，相對於傳感器座標原點，毫米爲單位）.

手掌移動的速度（毫米每秒）.

手掌的法向量（垂直於手掌平面，從手心指向外）.

手掌朝向的方向.

根據手掌彎曲的弧度確定的虛擬球體的中心.

根據手掌彎曲的弧度確定的虛擬球體的半徑.

其中，手掌的法向量和方向如下圖所示：

「手掌球」的圓心和半徑：

對於每個手掌，亦可檢測出平移、旋轉（如轉動手腕帶動手掌轉動）、縮放（如手指分開、聚合）的信息。檢測的數據如全局變換一樣，包括：

旋轉的軸向向量.

旋轉的角度（順時針爲正）.

描述旋轉的矩陣.

縮放因子.

平移向量.

Leap 除了可以檢測手指外，也可以檢測手持的工具。像上文所說的，就是細的、筆直的、比手指長的物件：

對於手指和工具，會統一地稱爲可指向對象（Pointable Object，抱歉不太會翻譯），每個 Pointable Object 包含了這些信息：

長度.

寬度.

方向.

指尖位置.

指尖速度.

方向和指尖位置如下圖：

根據全局的信息、運動變換，手掌、手指和工具的信息和變換，開發者就可以靠這些來製作遊戲、程序了。

大概就是這樣了~

參考：

Leap Motion 的開發者文檔

Leap Motion | Developers

赞同：155

评论：19

怎么能够体会到 Google 的强大？使用时有什么技巧以及方法？

UTFG

,

http://g.openibm.com

（以下视频需要ipv6,vpn或gae搭配观看，具体方法请自行搜索）

你可以用google找到属于你的超新星

youtube.com

残疾人用他找到更好的假肢

youtube.com 的页面

冲浪者找到前无古人的冲浪点

youtube.com 的页面

黑客找到可以注入的网站

google.com.hk 的页面

。。。

了解十几年来 Google 的成长细节:

Our history in depth

附送：银河系搜索指南

网络历史记录

从简单的字词入手

自动纠正拼写错误

使用适合网络搜索的字词

字词越少，结果越多

完全匹配搜索

使用描述性字词

无需担心大小写问题

在特定网站内搜索

无需担心标点符号问题

按文件类型搜索

包括或忽略您搜索查询中的字词和字符

查找相关网页

查找食谱

搜索某个范围内的数字

进行数值换算

查询时间

进行货币换算

用中文看几十种 语言的网页

查看天气

查询实时股票价格

通过 Goggles (拍照) 进行搜索

包裹跟踪

查询字词定义

使用高级图片搜索功能 进行搜索

数学计算

按地点搜索

按邮编和区号 搜索地点

网上购物，货比三家

查询电影放映时间

用图书搜索看免费书

限定数字范围

查看航班时刻表

检查健康状况

查看航班时间

看不同视角的国际新闻

搜索地址

类似字词

按语音搜索

查找本地商家

查询互动财经信息

查找药品信息

移动设备上的即搜即得

在移动设备上使用即时预览

按地点搜索

查询互动天气信息

图文并茂

用中文走遍世界

用中文走遍世界

用中文走遍世界

用中文走遍世界

对着计算机说话，也可以进行搜索

上不了谷歌？瞧我签名。

赞同：145

评论：6

什么程序设计语言机制是处理异步 IO 最恰当的抽象？

Rio

,

「IT 公论」主播

先声明一个基本假设：人的思维是线性的。程序员也是人，思维当然也是线性的。线性这里指的是事件发生顺序的前因后果关系。如果你不认同这个假设，下面讨论的几种风格的区别意义不是很大。

基于回调的异步 I/O 风格（如 Node.js 和 Python Twisted）会导致控制流倒置（inverse of control flow），使得事件发生的先后顺序不清晰明了，从而造成代码的理解和调试困难。在 Node.js 出现之前，广泛使用的 Python Twisted 库大量使用了这样的风格。一般认为这样的代码可维护性很低。基于回调的异步 I/O 的优势在于其开销小、效率高。单线程的架构也避免的多线程修改可变状态的锁的问题（当然单线程也是个限制，能够有效利用多核的方式局限于多进程）。

基于线程的同步 I/O 风格则没有这个问题：每个线程相对独立，且线程内部的控制流是线性的。理解和维护基于线程式的代码相对容易（先不谈锁的问题，不是这里讨论的重点，这里只考虑用于 I/O 的场景）。基于线程的同步 I/O 的问题是它的可扩展性很低，因为每个线程的内存开销大，在线程间切换的开销也大。对于需要处理成千上万连接的网页服务器而言，这样的开销无法接受。

很多人于是尝试保留回调和线程风格的好处（低开销、线性控制流），但同时避免他们的缺点（高开销、倒置控制流）。协程（Coroutine）[1] 可以比较好的解决这个问题。协程允许将某个子程（Subroutine）的运行状态保留下来以便将来重入（re-entry）。也就是说，协程可以随时暂停运行，将控制返回给调用者，等条件成熟时再从暂停点继续运行。基于协程的异步 I/O 和基于回调的异步 I/O 在性能上相当，但因为协程的内部逻辑顺序是线性的，不会导致控制流倒置。主流语言中，Python 的 Generator 和 Ruby 的 Fiber 都是协程的例子。在异步 I/O 的语境下，可以将协程理解为回调模式的语法糖（当然协程还有其他的好处）。基于协程的异步 I/O 风格主要难点在于要自己写调度器（scheduler）在多个协程间切换，而且每个协程要记得频繁让出控制避免其他协程僵死。这和回调风格一样。协程现在还不那么流行，被广泛理解和接受可能还需要一些时间。

单一进程下，单纯基于回调或者协程都无法有效利用多核处理器。条件允许的情况下，一般采用运行多进程进行负载分流。基于线程的方式理论上可以利用多核，但在 Python 和 Ruby 这样有全局解释器锁（Global Interpreter Lock）的官方实现里，通常只能同时运行一个线程，多线程的优势也就局限在线性控制流，负载分流还是得通过运行多进程实现。Python 和 Ruby 的 JVM 实现由于没有全局解释器锁，不存在这个问题，多个线程可以同时运行。

线程当然不是一无是处。问题描述中引用的文献认为线程不好，是在特定的情景下（系统瓶颈主要是 I/O），且当时（2005年以前）多核处理器并非主流、内存相对有限。自从 Linux 2.6 内核开始搭载 NPTL [2] 后，线程的开销（内存、切换）其实已经降低很多了。此外，现在的服务器多核已然是普遍现象，10GB 以上内存也很常见，上万个线程的开销已经不是问题。线程模式可以不用对程序进行特别修改就能利用越来越多的处理器核心（另外一种形式的性能『免费午餐』）。为了优化使用事件驱动的模式而必须进行的状态切换等协调操作进化到最后会成为另外一种形式的线程调度器，某些场合下还不如直接用系统的更加成熟的线程调度器。

像 Erlang [3] 这样采用定制化调度器+轻量级线程的模式也很有意思：Erlang 的线程并非系统线程，而是 Erlang 自己管理的、类似协程的机制。和 Python、Ruby 的协程不同，Erlang 的轻量级线程切换不需要手工管理让出控制。Erlang 的调度器会在某个线程执行一定步骤（Erlang 的语境下称为『缩减』，reduction）后自动切换。这一点更加类似系统线程：内部逻辑是连续的，可以使用同步 I/O，同时又没有系统线程高开销的弊病，可谓一石三鸟。唯一问题是，这个太小众了……

另外值得一题的还有通过多个进程/事件循环提高事件驱动 I/O 性能。比如 Nginx 的工人进程（worker process）。每个工人是单独的事件循环，和其他工人独立。每个工人使用轮询机制（如 poll/epoll）时只需要处理自己手上的套接字，效率相对要高些。多核处理器上，通常为每个核心分配一个工人，这样互相之间不会为抢系统资源打架。

[1]:

http://en.wikipedia.org/wiki/Coroutine

[2]:

http://en.wikipedia.org/wiki/Native_POSIX_Thread_Library

[3]:

http://en.wikipedia.org/wiki/Erlang_(programming_language)

赞同：112

评论：8

马天夫

,

长期无业者

对javascript不懂.但是thread model vs event model是计算工业由来已久的争论话题。你可以在网上搜索why thread is evil或者why event is evil，都能找到业界顶尖专家的针锋相对的争论。

从编程角度说，如果不考虑性能，如果开发环境提供thread，那就一定要用thread.用thread写出的代码逻辑是连续的和内聚的，没有事件覆盖问题.当然它有死锁问题，而且数学上无法避免。

如果要使用Event Model.系统不能太大，Event路由机制、处理的优先顺序应该简单明了，否则程序的控制流将非常难以理解。在事件路由上挂钩子是应该极力避免的。对并发事件要充分展开，避免出现循环触发。在性能可以接受的情况下尽可能把逻辑正交化，把无关逻辑用periodical polling的机制来处理（包括延迟处理）。每个子系统应该遵循Reactive的设计原则，即当一个外部事件进入时（包括时钟事件），一定要在这个系统内部队列完成全部处理之后再抛出新的事件，采用缓冲延迟的方式。给每个子系统写一个内部事件队列是不错的做法，如果觉得麻烦，用Observer Pattern也是一个办法.抛向全局的事件队列是最后没办法的办法。

事实上任何Event Model的逻辑都可以用从上层（粗粒度系统）到下层的顺序调用来完成，在处理的每个步骤，前一个子系统返回自己的state change提供给后面的子系统使用，后面的子系统可以使用这个state change和访问已经被处理过的前面的子系统的状态更新自己的状态，处理过的子系统的状态保证是consistent的，顺序处理完所有的子系统之后，整个系统的state也是consistent的。你很容易用assertion来验证这一点。

如果一个子系统依赖于多个子系统的状态，这样的做法就会看到所有的并发和多重依赖关系，它体现在你会发现一些子系统的事件处理函数需要把外部事件、多个其他子系统的state change，和另外一些子系统的引用都送进去，看起来有点儿怪？错！这是最美妙的时刻，因为这就是并发情况的显式定义，而且你必须在设计阶段去考虑这种情况，而且你必须在一个子程序内把它搞定（逻辑内聚）。

这对处理并发问题是非常好的，它相当于在设计阶段人肉展开了程序的state space。如果你在设计阶段展开了这个逻辑，定义了所有情况下的处理顺序，这个程序的state就是被穷举的，它的测试工作将非常容易进行.而且系统没有未知的、似是而非的、应该会工作的状态存在。

当然Event Model也不是噩梦，它有特别美妙的一个地方就是你在程序逻辑发生翻天覆地的变化时，你会发现程序的框架竟然基本不需要改动，代码很容易线性增长.但是如果你是为了这个目的而使用Event Model，我只能祝你好运了，兄弟！

赞同：32

评论：1

在编程和算法领域，有哪些经典问题？

Clyde

,

攻城狮，程序猿，测试狗。

刚刚才看到一篇百度百科经典算法合集，贴到着来。共勉啊亲~！

排序

排序算法:

http://baike.baidu.com/view/297739.htm

冒泡排序法:

http://baike.baidu.com/view/1313793.htm

起泡法:

http://baike.baidu.com/view/174304.htm

鸡尾酒排序:

http://baike.baidu.com/view/1981861.htm

桶排序:

http://baike.baidu.com/view/1784217.htm

计数排序:

http://baike.baidu.com/view/1209480.htm

归并排序:

http://baike.baidu.com/view/90797.htm

排序二叉树:

http://baike.baidu.com/view/922220.html

鸽巢排序:

http://baike.baidu.com/view/2020276.htm

基数排序:

http://baike.baidu.com/view/1170573.htm

选择排序法:

http://baike.baidu.com/view/1575807.htm

希尔排序:

http://baike.baidu.com/view/178698.htm

堆排序:

http://baike.baidu.com/view/157305.htm

快速排序算法:

http://baike.baidu.com/view/19016.htm

插入排序法:

http://baike.baidu.com/view/1443814.htm

树形选择排序:

http://baike.baidu.com/view/3108940.html

========================================================

搜索

深度优先搜索:

http://baike.baidu.com/view/288277.htm

宽度优先搜索:

http://baike.baidu.com/view/825760.htm

启发式搜索:

http://baike.baidu.com/view/1237243.htm

蚁群算法:

http://baike.baidu.com/view/539346.htm

遗传算法:

http://baike.baidu.com/view/45853.htm

========================================================

计算几何

凸包:

http://baike.baidu.com/view/707209.html

========================================================

图论

哈夫曼编码:

http://baike.baidu.com/view/95311.htm

二叉树遍历:

http://baike.baidu.com/view/549587.html

最短路径:

http://baike.baidu.com/view/349189.htm

Dijkstra算法:

http://baike.baidu.com/view/7839.htm

A*算法:

http://baike.baidu.com/view/7850.htm

SPFA算法:

http://baike.baidu.com/view/682464.html

Bellman-Ford算法:

http://baike.baidu.com/view/1481053.htm

floyd-warshall算法:

http://baike.baidu.com/view/2749461.htm

Dijkstra算法:

http://baike.baidu.com/view/7839.htm

最小生成树:

http://baike.baidu.com/view/288214.htm

Prim算法:

http://baike.baidu.com/view/671819.html

网络流:

http://baike.baidu.com/view/165435.html

========================================================

动态规划

动态规划:

http://baike.baidu.com/view/28146.htm

哈密顿图:

http://baike.baidu.com/view/143350.html

递推:

http://baike.baidu.com/view/3783120.htm

========================================================

动态规划优化

优先队列:

http://baike.baidu.com/view/1267829.htm

单调队列:

http://baike.baidu.com/view/3771451.htm

四边形不等式:

http://baike.baidu.com/view/1985058.htm

========================================================

其他

随机化算法:

http://baike.baidu.com/view/1071553.htm

递归:

http://baike.baidu.com/view/96473.htm

穷举搜索法:

http://baike.baidu.com/view/1189634.htm

贪心算法:

http://baike.baidu.com/view/112297.htm

分治法:

http://baike.baidu.com/view/1583824.htm

迭代法:

http://baike.baidu.com/view/649495.htm

加密算法:

http://baike.baidu.com/view/155969.htm

回溯法:

http://baike.baidu.com/view/45.htm

弦截法:

http://baike.baidu.com/view/768310.htm

迭代法:

http://baike.baidu.com/view/649495.htm

背包问题:

http://baike.baidu.com/view/841810.htm

http://baike.baidu.com/view/1731915.htm

八皇后问题:

http://baike.baidu.com/view/698719.htm

百鸡问题:

http://baike.baidu.com/view/367996.htm

二分法:

http://baike.baidu.com/view/75441.htm

kmp算法:

http://baike.baidu.com/view/659777.html

遗传算法:

http://baike.baidu.com/view/45853.htm

矩阵乘法:

http://www.douban.com/group/topic/12416781/edit

Floyd算法:

http://baike.baidu.com/view/14495.html

路由算法:

http://baike.baidu.com/view/2276401.html

ICP算法:

http://baike.baidu.com/view/1954001.html

约瑟夫环:

http://baike.baidu.com/view/717633.htm

约瑟夫问题:

http://baike.baidu.com/view/213217.htm

AVL树:

http://baike.baidu.com/view/414610.htm

红黑树:

http://baike.baidu.com/view/133754.htm

退火算法:

http://baike.baidu.com/view/335371.htm#sub335371

并查集:

http://baike.baidu.com/view/521705.htm

线段树:

http://baike.baidu.com/view/670683.htm

左偏树:

http://baike.baidu.com/view/2918906.htm

Treap:

http://baike.baidu.com/view/956602.htm

Trie树:

http://baike.baidu.com/view/1436495.html

RMQ:

http://baike.baidu.com/view/1536346.htm

LCA :

http://baike.baidu.com/view/409050.htm

矩阵乘法:

http://baike.baidu.com/view/2455255.htm

高斯消元:

http://baike.baidu.com/view/33268.html

银行家算法:

http://baike.baidu.com/view/93075.htm

*分类参照维基百科里算法的分类

http://zh.wikipedia.org/zh-cn/%E7%AE%97%E6%B3%95

赞同：139

评论：8

仅仅从好玩程度考虑，做编译器或操作系统哪个更有趣味？

蓝色

我做过操作系统，也做过编译器。操作系统当然是纯粹好玩，是拿开源系统来鼓捣鼓捣的，编译器是IBM编译器，这个当然是工业水准的编译器了。所以，如果拿这个来说的话，可能没有办法来完全对等的比较。不过我最近在做对接LLVM的编译器（当然这必须是离职IBM了才能做的，在IBM没有经过允许，是不能碰开源的代码的，GCC和LLVM都不行，我相信任何一个公司都是如此，代码污染必须是考虑的），也算好玩的一种，这个可以和以前鼓捣的操作系统来对接比较，可以顺带说一下了。

操作系统和编译器都很难，需要的知识不尽相同，如果真要说哪个门槛更高一些，其实还真不好说，两个涉及的东西都多如牛毛。按照大部分的学校开设时间，编译器总是安排在了操作系统后面，其实这也是可以理解的，因为编译器要打交道的东西很多，硬件体系架构、OS都是他针对的范围。所以，编译器的测试也是极其繁琐、以及精细，这里就不说了，因为我相信题主不是去做商业编译器，商业操作系统的测试我相信肯定也是非常麻烦的。

而从我的经历来说，哪一个更好玩呢？我觉得是编译器，尤其是编译器前端和代码优化。做编译器前端，你当然会与语言标准打交道，C++标准虽然很多人都喷太麻烦了，但是我倒觉得很好玩。因为我去设计解析C++语言代码的时候，我会去把相关地方的C++标准都读一下，然后会锻炼你的细致。而解析成功后，你会有非常大的成就感，你会体会到一个C++程序是如何变成一个一个Token，再被一步一步的完成解析，生成AST，完成Type Analysis，Diagnostic等若干过程，这种喜悦感是难以描述的。而当你有经验后，你可以自己去设计一门小语言，然后去完成解析，借助LLVM，或者其他的VM，然后去运行生成目标代码，就完成了语言的设计，这是多么大的自豪感与成就感。其实就今天的编译技术与工具而言，设计一门小语言已经不算一回事儿了，有太多的工具可以利用了。但是你手工去完成Scanner，Parser，AST，Symbol Table，Code Generation这种一波流，那是有非常大的锻炼价值的，当然也有各种奇葩问题，不过奇葩正好，奇葩才好玩。当然前端觉得已经搞得差不多了，那就是各种代码优化，这个优化真的就是穷其一生都可以搞得东西，各种算法多如牛毛，搞现成的优化算法就够你喝一壶了，你也可以尽其一生追求更极致，创造个编译器选项-OBest你就牛逼了。当然你要坐高级优化算法，你自己搞其实不行的，我一直觉得高级优化算法掌握在了IBM等巨头手上。LLVM虽然说其优化很牛，但是引用IBM前同事Kit的话来说，LLVM的优化和IBM的优化相比其实是个渣，如果有发现LLVM的优化做了，IBM没做的直接告诉他，他来做（这就是大牛的风采与自信）。

下面说说操作系统，操作系统好不好玩？当然好玩，也被誉为是很有难度的东西。OS核心部分我个人愚见是中断处理、CPU调度、（虚拟）内存管理、文件系统，你做一个小型OS的话，你能把这四部分做出来，就算一个麻雀OS了。而在中断处理这部分，你会很直接的与硬件打交道，你也会去追踪Bootstrap的过程，这对于你来说，有一个醍醐灌顶的过程，终于理解了OS启动的时候发生了什么。然后做CPU调度的时候，你当然可以采用Round-Robin这样的轮询法，完成一个低级的调度算法，如果你做的难一点儿，可以加上进程的优先级，来采用有优先级的调度算法。不过我觉得都还不算事儿，这很成熟了。然后内存管理这一块儿，我觉得很好玩儿，这也是最有意义的部分，你终于可以感觉到有主人的感觉，把计算机的内存捏在手上，这里面也有各种算法，LRU，FIFO等Page Fault的算法。文件系统是我们经常打交道的东西，你也能终于体会到文件在我们OS中是如何表示了，然后也能理解设备为什么可以用文件表示。

总的来说，做OS你像一个去追寻本质，醍醐灌顶的过程，而好玩性来说，编译器更好玩一些。

嗯......我又吹了这么久的牛了。

赞同：128

评论：23

品雪

,

人生如梦

认真做都很有意思。

做编译器最好连语言一块折腾了，如果定义一门语言太麻烦，那也找一门熟悉的语言自己写一下 BNF ，如果直接用现成的，那最有意思的部分就没赶上。曾经 sand-stone 出过一个叫 VisualParer++ 的商业产品，可以调试文法，可惜这个市场实在太小了，如今 sand-stone 的域名已经出售，曾经的竞争者们也都消失了，刚搜了一下，似乎

VisuaLangLab

还不错，不过没用过只能您自己去试了。

单纯折腾编译器的话，代码生成步骤最好对接一个现成的 VM，如 JVM， 或者干脆对接 LLVM 后端，不建议自己写 runtime，那个跟编译器完全是两个工程。直接生成机器指令的话，还需要理解 Linker & Loader ，不过这个倒是非常实用的知识，书只见过那本老掉牙的

Linkers and Loaders (The Morgan Kaufmann Series in Software Engineering and Programming): John R. Levine: 9781558604964: Amazon.com: Books

，零散的文章倒是很多。

代码生成时的优化是很有趣的，非常有挑战性，是真正需要创造力和想像力的前沿领域，有太多乐子可找 。可以考虑拿现成的编译器的 LLVM 实现专练这个。

简单的操作系统实现也就是个体力活，找本自己动手写操作系统、30天自制操作系统之类的书操练一下就是了，如果对硬件架构不熟倒是会接触很多新鲜东西。做一个有工业水准的操作系统就有趣多了，多处理器支持、虚拟化、调度算法、进程沙盒……，太多太有搞头的方向，不过在现有开源系统上折腾可能会更省事一点。Solaris 这么高大上的系统居然也开源了，直接啃这个吧，

illumos Home

，实时系统推荐

RT-Thread | 启动下一代RTOS演化

。

赞同：6

评论：2

互联网编程如何入门，学习路径大致是怎样的？

vczh

,

专业造轮子 www.gaclib.net

如果你一定要

整个知识框架体系

，那东西就多了啊。你要做的东西大概按顺序如下：

1：学会用C++和socket或windows的http server api做一个http server，搞成一个小网站

2：多加几个网页之后你就明白为什么大家总是需要一个template语言/工具了，然后你可以试着自己开发一个

3：于是你开始试图做动态网页，你就要用jquery和XMLHttpRequest修改html本身还有和C++服务器进行数据交换

4：然后你开始给你的网站加一个Windows桌面的客户端，这是对模块化能力的重大考验

5：你会发现你重复了很多代码，所以开始使用MVC和一些小的设计模式来帮你划分模块

6：然后你发现，尽管C++用IOCP是很方便，但是拼HTML字符串还是难爆了。于是你开始尝试把C++服务器改成纯粹的功能服务器，然后用一个薄薄的http server来host你的网页，网页开始用js获取后台数据，然后用js调用你的新template工具来生成HTML，再也不要在C++里面拼字符串了。

=========================================

做到这里，你的小网站已经变成了 C++功能服务器/不知道什么写的http server/js+template+ajax的browser端/不知道什么写的GUI客户端

=========================================

这个时候你差不多可以用你学到的知识来做你想要的东西，于是后面你就面临几大问题

1：用户登录怎么做。authentication是需要特别丰富的知识的，而且在天朝不能因为【哔—】规定你要给【哔—】提供用户的密码你就非得把密码的明文保存在生产环境里等着被拖库。

2：用户太多了，功能服务期一台机器hold不住了，你需要写分布式系统

3：客户端渐渐蔓延到了windows phone、android、ios。如果你不让view层变得很薄，你就会在各种端和语言里面重复实现你的controller，做大了之后简直无法维护。

=========================================

做到这里，你基本上已经碰到了如何在各种奇葩的语言之间交换数据的问题了。当然这个问题肯定很早就被人解决了，但是因为你需要学会

整个知识框架体系

，那你一定会开始去山寨一个你自己的protocol buffer这样的东西。服务器也开始知道如何用restful http server来把功能抽象成model了，然后你的MVC到这里就正式学会了。

=========================================

然后你开始加入公司，发现，卧槽之前做过的东西，别人都不愿意用你的代码，而用别人的代码。然后开始苦逼的学习各种奇怪的脚本语言和框架了。苦逼了半年之后你发现，这些东西竟然都不如你做的，于是出来创业，出新的产品，拳打node.js，脚踢

http://asp.net

mvc，成为CEO，赢取白富美，走上人生巅峰。

一个web系统每一个地方展开了之后都有无限的问题和细节可以讨论，你应该做好准备花大量的时间，一点一点了解他们。

====================================================

发现了题主还要COM，这个实在没什么好办法啊，看《COM 本质论》吧。看得懂就懂，看不懂就算了，反正大部分情况下我们也只需要用简单粗暴的方法来理解那些COM写成的API就行了。

赞同：124

评论：40

作为一名做 Web 开发的 Java 工程师，算法在工作中基本不怎么用到，但为什么面试总会问算法的问题？

Cat Chen

,

上知乎，求欢乐

Web 开发啊？不如我问你一个很简单的问题啊。

现在大家用 JavaScript 都讲求模块化，例如 AMD、CMD 之类的。假设网站上要用到的功能都是 JavaScript 模块，它们的依赖关系也是已知的，页面对这些模块的依赖关系也是已知的，例如页面 X 需要模块 A、B，页面 Y 需要模块 B、C。我们也知道通常网站在发布时会把非常多的 JavaScript 源文件打包成少数几个文件，这样可以减少对每一个源文件独立请求一次的开销，但又能保证几个文件能够并行下载。

简化的问题是这样子的：假设只考虑上面提到的页面 X 和 Y，模块 A、B、C，请问该如何打包？说得直白点，应该分两个打包 [A, B] 和 [B, C] 还是就一个打包 [A, B, C]？假设我们已知页面 X 和 Y 的流量，也有数据能够表明多少访问页面 X 的用户会点击打开 Y 的链接，或者是反向。假设我们也有 TCP/HTTP 性能开销的数据。如何计算以便作出判断？

真实存在的问题其实是这样子的：对于好像 Facebook 这样复杂的网站，如此之多的页面和模块以及如此复杂的依赖关系，如何打包模块才能使得用户在下载 JavaScript 文件资源时的时间开销尽可能小？Facebook 是有专门一套概率模型来解决这个问题的，感兴趣的话可以自行搜索 Velocity 相关视频。

你只看着你手头上的问题和工具，当然说不需要扩充工具包了，因为你没想过要去解决更大的问题。你要敢去想象那些看起来无法解决的问题，然后才知道自己缺了什么。

赞同：90

评论：14

庄表伟

,

爱阅读、爱思考、爱生活、爱老婆、爱点宝、爱IT、爱美食、爱旅游、爱聊天、我是庄表伟，我爱这一切。http://www.zhuangbiaowei.com/

我一般不在面试的时候，问候选人算法题。因为，通常算法题，都是最容易事先准备好答案的。

我一般会问候选人在实际工作中，碰到的问题，然后追问、追问、再追问。看看他面对这个问题，究竟做了多么深入的思考，以及尝试过多少种解决的方案。

再换一种思路，假设我给你一个算法题，你以前没有遇到过，你会有怎样的思路？打算如何下手？有哪些可能的尝试方向？通过这些我也可以考察出你的水平高低来。毕竟，工作中遇到的大多数问题，都远远比那种一句话能够说清楚的算法题，更加复杂。

再换一个角度来谈，面试策略。一个面试官给你一道算法题，说明他至少是清楚的。这当然也是他懒惰的一种体现。你如果能够通过现场的思考，将他引向更加有深度的领域，那你就转变一个主导者了。

再谈一点：你到这里来提问，似乎想有人告诉你：算法并不重要。我可以贴一个以前的文章给你，算是帮你说两句，题目是《算法算老几》

http://www.iteye.com/topic/65655

1、无论是做软件，还是任何其他行业，甚至包括做人，很多时候，都是在解决问题。遇到麻烦，想办法解决。

2、最简单的问题，就是能够在书上找到现成答案的问题。比如：哪种排序的效率更高。

3、如果一个问题，书上没有现成的答案，能够通过Google、查找相关论文等等手段，找到答案的，也是简单问题。

4、如果，搜索不到现成答案，但是能够找到询问的人，问出答案来。比如Google不到，只能到论坛来求人，哀告，冒着被隐藏的危险提出问题。无论当事人觉得如何困难，其实都是小Case。

5、如果无论如何都找不到答案，怎么办？自己找呀！比如，这是一个开放源代码的项目，那就看代码。如果源代码都不开放，那就Hacking。反编译、debug、单步跟踪、设断点、打log，用尽一切办法，找到答案。

6、有很多问题，根本就是左右为难，你也知道了整个困难的全貌。然后怎么去解决他呢？左思右想，反复权衡，尽可能找到最好的方案。甚至如果有创意的话，能够想到一个两全其美的解决方案。

7、更加困难的问题是：它根本就没有正确答案，没有最优解。连如何评价各种解决方案的好坏，都说不清楚。怎么办？你还是得做出决策，然后执行。

8、再进一步，它本来就没有问题。但是，一个原本已经解决了的问题，你现在来考虑，有没有可能存在更好方案。比如：新的切入点.新的框架.新的语言.新的开发模型。这就更加困难了。

不再把人的问题牵涉进去了，那是没底的。

那么，算法算老几？

赞同：32

评论：13

可以用Python编程语言做哪些神奇好玩的事情？

向小刚

,

我不想谋生，我想生活。

先自己答一个，期待牛人的回答。

自己学Python不久，列举自己做过的和知道的。

1. Python做爬虫很方便，有现成的库。 我在学习python的过程中也遇到过一个非常简单的例子，代码：

python/primer/20/Cralwer.py at master · xxg1413/python · GitHub

。好像有开源的项目叫什么

supercrawler

，具体可以看看。

2.Python做游戏。Pygame还是不错的，但只适合做小游戏。用Pygame写个植物大战僵尸还是可以的。推荐教程

用Python和Pygame写游戏

。Python在游戏服务器方面也有应用。EVE这种游戏都大量用Python。

3.Python作为黑客第一语言，在黑客领域的应用就不多说了。

4.Python做网站，有几个web框架

WebFrameworks

。 用得最多的是Django。

5......各方面都有，什么推荐系统，都是用python，在此就不一一列举了。

——————————————————————分割线——————————————

一些有趣的事情：

1. goagent 大家都懂。评价最高的开源项目。 最近出了GUI版本。

goagent - a gae proxy forked from gappproxy/wallproxy

2.前段时间看到有一个外国的教授用python检测墙的位置，具体可以在Github上搜。

3.Sphinx

4.......还有很多，欢迎补充。

赞同：122

评论：15

有哪些适合程序员读的人文书籍？

萧井陌

,

░▒▓██不用电脑的程序员

update

更新部分评测

++++++

程序员也是人, 程序员的整体素质在其他行业也是通用的.

so....这就产生了很多其他行业的书...

当头棒喝 <

丑陋的中国人 (豆瓣)

>

精神胜利 <

中国人的精神 (豆瓣)

>

三省吾身 <

中国人的性格 (豆瓣)

>

(以上是君子之道)

因为你时间少嘛... 先节约点时间<

卓有成效的程序员 (豆瓣)

>

(读完后, 我就琢磨把第一个工作辞了, 然后2个月后就辞了)

因为你要学习嘛... 肯定要掌握方法 <

Mindstorms (豆瓣)

>

(读完后, 我开启了心智, 得到了升华, 开始投入于梦想中的事业)

因为你要读书嘛... 必不可少你要阅读 <

如何阅读一本书 (豆瓣)

>

因为是程序员嘛... 必然是要先自我洗脑 <

学会提问- 批判性思维指南 (豆瓣)

>

. 往家国之大了说, 你不会被骗去码长城, 往个人之小了说, 你不会被vim粉丝诓走 (笑

下面还是赶紧开始专心扯程序员吧..

只挑最通用最精简的来

先做个基本正常人 <

少有人走的路 (豆瓣)

>

(读完后, 开始重新审视自身并着眼改变)

再做个基本正常的程序员 <

程序员修炼之道 (豆瓣)

> (点名批判译名)

(读了四次, 做了很多笔记, 大学第一次后我转而使用emacs, 第三次是刚工作时读的, 和<卓有成效的程序员>配合起来效果绝赞, 直接就辞职了, 第四次是赋闲在家2年后读的, 每天下午时光在阳台踱步中翻看, 又做了一遍笔记, 我相信还会有第五遍阅读)

在正常人的道路上渐行渐远 <

你的灯亮着吗? (豆瓣)

>

在正常程序员的道路上渐行渐远 <

代码大全（第2版） (豆瓣)

> (点名批判这个译名)

(读了不下5遍, iPad中存了无数笔记, 作者说了很多政治不正确的大实话, 受用无穷)

已经脱离了正常的程序员 <

编程匠艺 (豆瓣)

>

(读了2遍, 因为是代码大全之后读的书, 所以收获没那么巨大, 但是也非常值得阅读)

工程初探 <

人月神话 (豆瓣)

>

(值得一再翻阅的软件工程不朽篇章, 去年因见一位豆瓣网友轻视此书, 遂撰文近万字与此君解释, 无他, 盖因此君乃是非CS出身的编程人才, 见其弃之如敝屣殊为可惜. 无奈世事大多如此, 令人扼腕)

认识自我 <

人件 (豆瓣)

>

触摸本我 <

理解专业程序员 (豆瓣)

>

了解局限 <

梦断代码 (豆瓣)

> (于我有特殊记忆的一本书, 看了两遍, 意犹未尽)

看看大师 <

编程大师访谈录 (豆瓣)

>

学学先贤 <

设计原本 (豆瓣)

>

翻翻语言 <

编程之魂 (豆瓣)

> (夹个私货,

编译器设计是计算机技术的基石!!!

)

打打鸡血 <

编程人生 (豆瓣)

>

发发横财 <

Founders at Work (豆瓣)

>

做做春梦 <

新机器的灵魂 (豆瓣)

>

补补漏洞 <

入侵的艺术 (豆瓣)

>

(以上都是激荡飘扬的连环画)

信仰 <

别闹了，费曼先生 (豆瓣)

> (打击宗教狂魔, 树立崇高信仰)

兴趣 <

黑客 (豆瓣)

> (此书可让你知道自己是否有成为大牛的可能)

聊天 <

软件随想录 (豆瓣)

> (衡量编程环境的佳作, (我通过了9项Joel Test))

吹水 <

编程之道 (豆瓣)

> (我的第一本编程书, 直接提高了眼界拓宽了视野, 我的一切发展与成就始于此书)

忽悠人 <

The Deadline (豆瓣)

> (项目管理的好书, 学会了忽悠人但从来只用来忽悠自己)

恶作剧 <

我是沃兹 (豆瓣)

>

穷开心 <

黑客与画家 (豆瓣)

>

有几许爱 <

重来 (豆瓣)

>

奇思妙想 <

奇思妙想 (豆瓣)

>

末日审判 <

失控 (豆瓣)

>

(以上这批书包含深刻的思想洞见, 是理解程序员, 展露编程真象的绝佳著作)

学习如何修摩托车 <

实用摩托车维修技术 (豆瓣)

>

艺术史与艺术鉴赏 <

哥德尔、艾舍尔、巴赫 (豆瓣)

>

APPL装逼指南 <

Folklore.org: The Original Macintosh

> (不好意思溃不成书...)

UNIX装逼指南 <

UNIX编程艺术 (豆瓣)

>

HACKER装逼指南 <

Eric S. Raymond五部曲

>

MSFT发家两部曲 - 上 <

Borland传奇 (豆瓣)

>

MSFT发家两部曲 - 下 <

观止-微软创建NT和未来的夺命狂奔 (豆瓣)

>

IBM一瞥 <

压力下的角逐 (豆瓣)

>

如果你时间少.... <

浪潮之巅 (豆瓣)

> (indeed, 作者是吴军, however, 纰漏难免. 权当偷懒的代价吧)

(以上是故事书, 都是些非常有趣的故事, 喜欢考古的朋友(不管你是否是程序员都)应该会很喜欢. 除非时间真的很紧, 否则还是不要读浪潮了, 作者虽然贵为大神, 但写书也有点像跳大神...)

别忘了学习自慰防身术 <

Hacker's Delight (豆瓣)

> (杀伤过大, 面试慎用..)

(另... 真的不能有编程书吗... <编程珠玑> <程序设计实践> <SICP> (虽然是编程书, 但不给链接不算给了吧..))

(最近在看<

The Art of Doing Science and Engineering: Learning to Learn (豆瓣)

>, 看上去很高大上, 但其实是一本小说(好吧为了防止喷子, 它只是像小说...), 不过还没读完, 所以也就没法推荐或测评了)

最后<

颈椎病康复指南 (豆瓣)

> 镇楼

好吧, 推荐一本书, 是真心的 -- <道德经>.

它不同于<易经>, 你能轻易看懂它, 并且会对你的生活产生很大帮助, 轻松达到生命的大和谐

act without doing, work without effort

think of the small as large, and the few as many

confront the difficult while it is still easy

accomplish the great task by a series of small acts.

这其实说的就是正交, 结构化程序设计和模块化程序设计嘛... (笑

(写到这里, 我好像发现找不到工作的原因了....

赞同：114

评论：13

技术人员在转向移动开发过程中有哪些经验和教训值得大家借鉴？

覃超

,

曾经沧海难为水，Facebook工程师

说“转型”可能我还不够资格，因为我从工作开始就直接在做mobile，只是之前在大学里面搞过一些程序竞赛和TopCoder的组件开发在桌面电脑上面，所以从一开始我就是还没完全定型的程序员，基本上什么东西都需要从头学习。第一次真正开发mobile程序还是在CMU读master的时候，那时做毕业论文，研究Android系统的安全性，于是第一次装了Android的文档和自己照着样例写了一个，感觉还挺不错（其实就是写Java）再后来就是进入Facebook后，从Boot camp毕业后就进入Mobile team，当时公司里面大部分人还是搞PHP的，但是公司鼓励大家做Mobile开发，说是以后的方向，于是我从一入职就开始了全面的Mobile开发。

个人的经验如下：

技术方面： 我个人感觉Mobile上面更加注重程序的效率，程序要简洁，速度快，同时复杂度要尽量低。另外就是在写程序时具体要注意的事项，由于Mobile的处理能力不及桌面电脑，所以要格外注意将非UI相关的操作放入到worker thread。相比开发桌面程序或者web app，亦或者是现在的iOS或者Android开发，MVC模式已经深入人心，它的本质就是把代码按照其做的事情分类，坐不同工作的代码在不同的模块里. Thread分类和它也类似。刚开始进行Android Facebook和Facebook Messenger开发的时候，我们的Tech Lead -- Jon Perlow 就在code review中不断指出我的很多操作还是像桌面程序一样放在主线程中，而Android下主线程即 UI thread，这样就很可能降低程序的流畅性。而且很多时候，也其中蕴藏着一定的平衡和折中。因为移入worker thread后，程序会出现很多async method call和callback function/class, 这样对代码的可读性和以后的维护都是挑战，同时线程的切换和对于共享资源的同步也是会带来性能的损失，所以在写的时候要具体问题具体分析。比如说大规模I/O操作和上百万次的循环，自然不用说.但是在很多情况下，就没有如此明显吧，比如说判断一个文件是否存在， new File(getDucumentFolder + "/xyz").exist() 也算I/O操作，那到底要不要移入worker thread呢？另外很多时候，你最开始的函数里面，可能操作非常简单，就直接在Main thread里就可，可是后来其他人在refactor的时候，将这些操作放开到好几个function里面去做，然后在以后的版本中，由于加入了新的feature，每个function里面都比之前要做更多操作的时候，就逐渐逐渐地让Main thread的负担加重，搞到最后给用户的感觉就是这个App功能是变多了，但也越来越笨重，越来越容易crash。所以说，不要在UI thread里做事这点，想必只要智商上80的人都懂，但是真正要执行的时候并不是如此得显而易见，而同时，公司里的项目都是多人作战，每个人一般都着眼于自己做的那一块，这样很容易就造成最后UI Thread里面的工作量远比开始设计的要多。

现在主要的手机平台就是Android和iOS，所以建议两个都要去了解，然后专注于一个平台。如果Android的话，除了看Google官网外（

http://developer.android.com/training/index.html

）， 很多时候当你具体要调用一个API，但是文档上面有疑惑的时候，最好的办法肯定还是能回到代码里面去确认。通篇浏览Android的代码肯定不现实，我个人（也是公司里面）觉得最有用的办法就是安装plugin：

https://chrome.google.com/webstore/detail/android-sdk-reference-sea/hgcbffeicehlpmgmnhnkjbjoldkfhoin

，然后搜到文档后，页面上直接有一个链接 (View Source)来方便查看代码。回到上面那个线程切换的问题，Android有三种办法：AsyncTask, Handler, Executor. 在代码里面（还有Stack Overflow上面的讨论），AsyncTask是最差的办法，它属于Google自己加入的一个Hack，大量在自己的Android App里面使用会发生阻碍程序性能的奇怪问题（因为你对它的worker thread pool没有任何控制）.Handler比较简单，适合将单个任务快速丢到另外的thread里面执行，但是从源代码就可以看出Handler本质上也是在调用executor。最后就是Executor自己了，它的坏处是比较复杂，不注意容易出错，但是好处就是性能好，而且功能强大。可以自己定义queue的属性，指定thread pool的大小，和筛选并处理

或者取消还没被执行的任务等等。所以只有在源代码里面去确认后，才会对每个模块在使用有直接和全面的了解。这样就能理解为什么公司里面Android的编程规范里面来一句“Don't use AsyncTask"是什么意思。（很多人问我为什么不能用AsyncTask，其实在Android API的document里面就有

http://developer.android.com/reference/android/os/AsyncTask.html#execute(Params...)

， 看它自己的注释。另外还有一个blog：

http://commonsware.com/blog/2012/04/20/asynctask-threading-regression-confirmed.html

) 多提一句，如果两个平台都做的话，还可以比较在iOS下面对线程切换的做法，iOS上鼓励的是使用GCD (grand-central-dispatch)。他们各有自己的特点，但是个人认为iOS的GCD更加简单，也更加符合人的思维。

另外就是UI方面，我做过Facebook Messenger for iOS的UI，但是设计毕竟不是来自本人之手，所以只当是自己的拙见。个人觉得UI越简洁越好，另外就是在设计UI的不要进入误区：认为app的Android版本和iPhone版本UI要一模一样。还有一些自己在做UI的时候，designer给我的细节性的建议：“比如text一般加一个pixel的半透明的shadow“， 按钮（透明）的实际大小一般比贴图再大一些，这样更方便用户触摸。

上面都是在讨论的时候，即兴想到的东西，没有太多整理。不过这两年在FB的打磨让我觉得最重要的不是你的技术多牛，写代码写得多快，而是适应力要强，能够也愿意push自己去转型。我见过不少人，之前对某一技术或者某一领域炉火纯青了，就一直想呆在自己的领域里，说是精益求精也好，说是吃老本也好，更有甚者就是想用老本的技术来用于新的领域。Mobile上面跑HTML5的离线App我觉得就是其中一个，具体细节我整理一下，放到另外一个问题里。

赞同：112

评论：7

HTTPS 和 OpenSSL 是什么关系？

云舒

,

阿里巴巴集团 资深安全专家，http://www.icylife.net

HTTPS可以使用TLS或者SSL协议，而openssl是TLS、SSL协议的开源实现，提供开发库和命令行程序。openssl很优秀，所以很多涉及到数据加密、传输加密的地方都会使用openssl的库来做。

判断基本是不需要的，你可以理解成所有的HTTPS都使用了openssl。以root身份执行命令：grep -l 'libssl.*deleted'/proc/*/maps | tr -cd 0-9\\n | xargs -r ps u，可以看到哪些进程加载了老版本的openssl库。

赞同：110

评论：21

程序员该有哪些职业道德？

陈妖村

,

剑桥大学NLP组//自由而无用的程序员

说一个我们公司的规定，任何代码commit，都*必须*配上与之配套的unit test。不管是java, python, C++。

有了unit test，不仅能保证你的代码在提交的那一刻是有质量保证的.并且能保证以后任何人能够重构你的代码的时候、或者做任何相关改动的时候也是有质量保证的。

顺便说一下，我们公司对文档要求并不严格。因为我们认为真正漂亮的代码是self-explanatory的。即通过良好的命名规范和代码风格，以及漂亮清晰的逻辑和结构，来保证在尽量少的文档的情况下，其他人能迅速看懂。

赞同：61

评论：13

空明流转

,

名义上的GPU架构猴，实际上打杂猴。实名喷，实名被喷。

遇到新技术、新人、新问题，你不懂就不要装懂。

别阻挠会促使你进步，让你干活更轻松的同伴。

赞同：39

评论：4

如何优雅地编程？

Brian

,

Software Engineer, Digital Artist

(中文翻译:

如何优雅地编程？

Thank you

@乔杰克

for an awesome translation!)

I've been programming since I was 12, and every day, I'm learning as much as I can to improve my programming technique. Here's some general guidelines I try to keep in mind.

Work with A Better Coder

The fastest way is to learn from a much better coder. Ask questions about design decisions and the libraries that she/he uses.

Copy Good Code

Yes, when you see a piece of good code that does something better than how you could've designed it, use

Ctrl-c

and

Ctrl-v

. Copy it and modify it and learn why it's better (usually because it's simpler). Just remember to also give credit to the original author.

Use Popular Libraries

Libraries will save you time because they prevent you from reinventing the wheel. Popular libraries are usually maintained by a community of experienced coders. Using the library will also likely enforce a better programming style. Just like how you would study vocabulary words to improve your language skills, learning new libraries improves your programming vocabulary. If you're ambitious, you can even look in the source code and see how the logic is organized.

Care About Style

In programming, form is function. For example, this is literally true in Python, where indentation indicates scope. But even for languages that are space agnostic, a clear style prevents errors. Good style also lends itself to documentation or, even better, is automatic documentation.

If you read a piece of code that's easy to understand, emulate its style and organization. And also read peoples' blogs about programming style.

Some basic style habits that I practice are,

Using long and descriptive function and variable names. Nowadays, your code will never burden a computer's memory just because of the extra bytes in a long variable name. Plus, if you use a compiled language, the compiler will replace all the names anyways. If you're lazy about typing long names, set up tab autocomplete.

Using action verbs for my function names. Instead of "getCorrectedName()", I use "rename()". In this case, 'rename' is a more precise verb than 'get' and it simplifies the function name.

Writing small functions that only do one task. If a function does more than one thing, I break it down into subfunctions that do only one thing each. This makes the code more modular and easier to debug. This also makes function names self-documenting.

Develop Iteratively

The most common reason that people give up on programming is that they don't enjoy the results of their work.

As you learn about more frameworks and libraries, it becomes tempting to write the whole project and then click run. It probably won't work. It's better to plan out the structure and then write tiny parts of the code. Test each part, experience the thrill of watching it work and then drop it into your overall project.

If you're an experienced programmer, create classes and objects, even for your small scripts. Even if you think, "Oh this'll be a script be for something small," if it works well, chances are you'll want to expand it or use it for something else. Instead of duplicating code or writing complex if-else blocks, it feels amazing to just inherit from the original class, make some small changes and have a newly customized application.

Use StackOverflow

Almost every common task and bug is solved on StackOverflow. Plus, the solutions are elegant and the answers give great explanations.

Write for Your Future Self

Imagine your future self either has amnesia or grows stupider (both usually feel true). It's always a satisfying feeling to look over your old code and be greeted by user-friendly documentation.

Use Version Control

Github hosts Git repositories (projects), Bitbucket hosts Git and Mercurial. If you aren't comfortable with command line programming, then I recommend using SourceTree and Bitbucket.

Share Your Code

Let other people use it, give you suggestions and ask for improvements. You're also more motivated to improve programs that other people are using.

赞同：81

评论：5

Python 在编程语言中是什么地位？为什么很多大学不教 Python？

Haoyuan Xing

刚毕业，正好我接触过各类背景的同学，从C/C++/Pascal/Java/Python入门的都有，讲讲我的感受，求轻拍

先讲个题外话：不要太低估国内大学计算机系的水平，国内比较好的大学开设的课程，其实都很紧跟国外的教学趋势的，前些年的Perl，最近的Python和ARM、hadoop，几乎都会有对应的课程。所以也可以不用那么愤青啦~

其实交大从去年开始电类专业的程序设计思想与方法就从C++转向了Python，用的教材是Core Python Programming. 基本上现在的格局是：

电类专业：一学期Python + 一学期C++

非电类专业： 一学期C++?

然后后面要用什么语言就自己去学吧，Java也好Verilog也好Haskell也好学校都不教了。

好处呢就是一开始Python的确比C++好上手啊。

坏处是：Python是一门好语言，但它不适合教学，特别是不适合电类的教学。结果是学弟学妹们并不是特别适应：

一方面，国内的硬环境，是除了计算机和生物类，几乎没有人大规模使用Python——对于很多行业内仍然在用VC6/MFC写界面的电气类学生，你教他Python，他还是要再回头学C++。更进一步说，由于C++的教学时间缩短，而人们又离不开C/C++——起码操作系统课要用，写ARM程序要用，所以反而使得新生没有办法专心掌握一种语言。

另一方面，Python并不适合入门：

Python之于C++，并不像是Lisp之于C，是

计算模型

的不同导致的简化。相反，Python和C++的计算模型都是命令式为主的，而Python的美好，在于自然而隐藏了很多细节，像自省啊词典啊动态化啊。但是Python本身的计算模型是比较杂糅的——有一点过程、有一点对象、有一点函数式。这就要求编程者要选用合适的方式来实现自己的方法——如

@莫宇诚

所述，这是很实用主义也很精彩的设计。但是命令式的计算模型和强类型系统决定了，这部分的复杂度并没有消失，只是隐藏了起来。理解这些复杂度，是能够顺畅使用Python的前提：我正在操作的是什么类型？这个for语法隐式的使用了哪个对象的迭代方法？方法有没有默认参数？

而偏偏，新生是很难理解这些的——在C语言里明明白白的写出来，都有很多人头痛，不要说藏起来隐式调用。就好像C++里的流，不深刻理解模板重载和迭代器，根本不会理解这东西“为什么能这么写”。

所以学Python和学C++的时候，都会有很多学弟妹惊讶的问——呀，为什么这个地方能这么写，不能那么写？我真的很难解释——因为这些问题，往往牵扯到类型啊对象啊继承啊——恰恰是语言的简单背后藏着的那些东西。

=========================

所以对于新生来说，我觉得入门的语言要的是简单：这种简单，不是指代码量上的短，而是指思维、语法和计算模型上的简单：让新手可以集中注意力理解少数几个概念，不需要纠结于很多惯用法啊隐藏的细节啊：那是给熟手加快进度用的，不是给新人学习用的。所以我觉得Python/C++/Java这种大型语言，都不适合入门——太复杂，太难掌握，最后只能学个皮毛，还不如教一种学生能吃透的语言，以后触类旁通。C/Scheme，在我看来是很好的语言：它还算好用，而且模型简单，学生容易彻底理解。日后比照着学习其他更加抽象化的语言，也更加容易。

至于C的缺点，是可以通过教学来改正的——教育学生合理的抽象，适度的隐藏，学会使用迭代和递归。而我觉得这，才是程序设计导论课区别于C++语法课的关键所在。但是很遗憾，不管使用什么语言，能讲到这个层次的老师，都太少了。（学生也不爱听，他们只关心怎么能做大作业，实现更多的功能）

=====================

其实MIT自己也认为现在学生用Lisp入门不太好，这里有一篇文章引用Sussman的话解释了原因。

http://cemerick.com/2009/03/24/why-mit-now-uses-python-instead-of-scheme-for-its-undergraduate-cs-program/

总之，语言教学这件事，重点不是要赶时髦，而是要接地气。

赞同：78

评论：13

Linux 内核的操作系统是不是得一直运行着？

高鹏

,

OS Kernel / Virtualization / Storage

当年上我老板的OS课，老板上来就告诉我们，OS不是运行着的代码，而是一堆躺在内存里等着被调用的代码。

内核就是一个由interrupt驱动的程序。这个interrupt可以是一个系统调用（x86下，很多OS的系统调用是靠software interrupt实现的），可以是一个用户程序产生的异常，也可以是一个硬件产生的事件中断。

于是你的问题解决了：一个用户程序运行的时候，Linux就在内存里呆着，等着一个中断的到来。在这个中断的处理过程中，来做“调度”。而一般的时分系统里，都会有个timer interrupt每隔一段时间到来，也就是楼上说的“时间片”。

PS：很多人在认识OS的过程中被大量的artificial concept给困惑了。比如神马进程，线程，调度，micro kernel，monolithic kernel的。从x86架构上来理解OS才是王道。

=================================================================

PS of PS: 把评论粘上来，补充上面的PS，谢

@许越

提醒：

因为很多教材在讲os的时候，更喜欢从app的角度来看待os，于是很多时候被各种概念绑架。因为很多例如进城，线程，系统调用这样的东西都是由os在硬件上抽象出来的。站在这些概念上看os，就有点“不识庐山真面目”的感觉。所以我的意思是从硬件的角度看os，反过来理解为何os要抽象出这些概念。站在cpu的角度，理解指令是怎么在cpu上一条一条的运行的。

赞同：74

评论：13

如何衡量一个人的 JavaScript 水平？

岳渊

,

一只程序猴子。。

@董超

给出的链接只是很基础的javascript语法考察（当然题目的确出得很棒），刷完一本《javascript高级程序设计》的入门者都可以秒答。

仅仅从语法上来考察javascript水平是不合适的，因为javascript和其他语言不一样的最重要一点就是依赖于宿主，光会语法什么都写不出，所以必须考察一些其他的要点。

以下是我为了准备14年9月面试阿里所做的笔记节选：（

仅仅是考察点

，具体题目和扩展再设计，因为有时候我是想到了才记下来，所以这些问题会不断更新）

基础

1，什么是命名空间，变量污染，变量声明提升，预编译？如何检查一段代码执行后是否声明了全局变量？

2，隐式转换的种种规则

3，关于对象，对象的属性可能有哪些特性(attribute)？什么是原型链？如何检测某一属性是在对象中还是原型链中？如何检测是否是普通对象或空对象？写一个工厂模式？(工厂模式也有很多细节，具体可以参考《javascript模式》一书，

不是

《javascript设计模式》)

4，变量类型检测、特性检测以及异常避免

5，setTimeout的特性

6，数组几个API的手工实现

7，事件

8，正则表达式，至少要明白$1和\1的意思和几个API的用法。

9，javascript如何获得随机unicode字符？

10，JSON.parse的参数传一个什么对象的时候不能处理？(可以试试JSON.parse(window))

11，fn.apply的第一个参数是context(函数运行的上下文)，那么这个参数传一个数组会怎么处理？

DOM操作

1，实现一些API如getElementsByClass（有很多细节，参见司徒正美的博客）

2，各种宽度高度(clientHeight之类)的含义及各浏览器之间的差异性

3，实现一个带回调函数的插入DOM节点API（须考虑script标签、documentFragment）

CSS操作

1，如何操作CSS的伪类和伪元素？

2，如何检测改浏览器是否支持某个CSS3的特性？

ajax操作

1，get和post的区别及使用要点

2，http协议，包括格式、状态码，cookie操作

3，跨域

4，转换JSON的几种方式，JSON.stringfy有什么使用限制？

性能

1，javascript有哪些性能优化的措施？可看《高性能javascript》

综合

：各种插件的设计思路

其他的html5相关和NodeJS相关暂略

赞同：69

评论：30

如何通过模仿大师来学习计算机编程？

隋龍飛

,

嘿，需要心灵鸡汤么？500块一小时，泼你一脸！

请认真的走大师们走过的路，而不是模仿他们现在的样子。

赞同：63

评论：5

如何深入理解多进程，多线程，非阻塞/异步IO(callback) 以及Coroutine模型？

vczh

,

专业造轮子 www.gaclib.net

我觉得这里有一个想法非常重要，而且很多人会弄错，先澄清一下：就是这些东西实际上是可以互相变换的，跟runtime说白了其实没什么关系，是编译器搞的把戏（当然这不是必需的）。

我举个例子，一个void Sleep(int)函数我直接调用它（阻塞），跟一个Task Sleep(int)函数我用await来调用它（CPS变换，某种程度上类似于Coroutine），真的有什么区别吗？当然如果具体到某个语言的实现，有可能区别还是挺大的。

但是！

Sleep是一个阻塞函数，假设语言对所有的阻塞函数都要求他的返回值是Task<T>（当然这里并不一定非得是.net的那个，这里的Task<T>仅仅是一个符号，大概就跟微积分的∫什么差不多，或者unicode的'A'差不多，只有精神上的意义），在类型上直接跟你指明了Sleep是一个阻塞函数，

从而让编译器知道这个函数就是阻塞的

，那也就真正达到了我第一段说的，他们是可以互相变换的。

这到底是什么意思呢，也就是说，你阻塞地调用一个阻塞函数（1），可以被编译器改写为用CPS变换来调用一个阻塞函数（2）（从而他不会阻塞你的线程——当然你的语言也不会把物理线程暴露给你，所以你实际上

无法通过在语言内部的测量来知道他们的区别

←这是一个重要概念），也可以被编译器改写为通过coroutine来调用一个阻塞函数（3），甚至可以被编译器改写为通过发消息给actor（假设有某个actor跟service一样来实现这个阻塞函数的功能）来调用这个阻塞函数（4），或者用原始的方法给一个callback，显示地异步地调用这个阻塞函数（5）。

上面的（1）（2）（3）（4）（5）是可以互相改写，还保持你的语言等价（所以你实际上

无法通过在语言内部的测量来知道他们的区别

←这是一个重要概念）。为什么能这么做呢，前提有两个。1：操作系统本质上对IO的处理是异步的，同步那些只是通过牺牲各种指标来给你制造方便的。这个前提在绝大多数能看得见的操作系统上都是成立的。第二个前提是，编译器知道那个函数就是阻塞函数。这个前提不太好实现，但是在C#里面，所有返回Task<T>的函数都具有这种性质。

于是，只要那个语言的类型设计得好，这几个概念就只有编译器玩玩把戏的区别。当然如果你用了什么乱七八糟的语言，他没有表达这个（譬如说go的阻塞函数是没有特殊类型的，除了ch和他那个奇怪的<-语法，但是ch有固定的意义，不是一个抽象，你不能用他来干别的），或者根本无法表达（譬如javascript那养），那这就变成了实现上的区别了。

于是你会知道，凡是不喜欢CPS变换（譬如C#的await那样的），就一定会喜欢类似windows上面的fabric的东西（go抄了去，变成了自己调度的goroutine）。因为如果你都没有，那很多线程同时调用阻塞函数就会大量浪费系统资源。你采用了fabric，就类似于把这个节省资源的算法做进了操作系统或者是你的runtime。你采用了await，就类似于吧这个节省资源的算法坐进了编译器。

那你说其实有什么区别呢？我觉得分析到了这里，他们也就只有形式的区别了。

赞同：56

评论：35

开启浏览器的「Do Not Track」后，会对浏览造成什么影响？

Kenny Lang

,

热血的青年软件工程师 / Googler

Short answer: 现阶段对于用户体验（尤其是浏览国内网站）而言，基本没有任何影响。

Long story: DNT有普遍意义上的设计缺陷。用户和部分开发者对DNT的理解和DNT最初的概念相去甚远。用户基本会将DNT理解为一个避免自己被track的工具。事实上，DNT的最初设计理念在于为第三方(third party) tracker 们提供一个统一的协议(protocol)来允许用户更容易的屏蔽(opt-out)他们的 third party tracking. 也就是说：原本支持用户opt-out被track的第三方（包括广告平台，data provider，tag management和社交网络等等）可以通过支持DNT而方便用户屏蔽被track。而那些原本不支持opt-out功能的tracker也不会因为DNT的出现而改变自己的隐私政策支持opt-out。因而，DNT的设计并没有任何技术手段强制第三方tracker不track用户，而仅仅是在HTTP请求的header field里加了一行DNT header。

DNT： 1

理论上，那些支持DNT的tracker在接收到带有这个header的HTTP request后应该立即停止对用户的track。那些不支持DNT的tracker则不会理会这行header。

问题出现了：这不是一个技术协议，而是一个政策协议，甚至连一个协议都算不上，只能说是一个请求：用户通过发送这个header而表达自己不愿意被track。至于tracker是否理会这个请求，则没有任何严格说明。更有趣的是，到现在为止，都没有一个同意的标准来规定什么样的HTTP response可以体现一个server/tracker尊重DNT。

对于一个第三方tracker来讲，尴尬的局面是：即使我尊重DNT，我也不能明确的让用户知道我对用户的尊重（除了写进基本没有人阅读的隐私协议）。而且，如果我声明自己尊重DNT，一旦经过某种测试认定我没有严格遵守DNT协议，我将会面临潜在的法律问题。更有趣的是，没有任何一个组织任何一个人要求我尊重DNT。所以，

我为什么要增加开发成本去支持DNT呢？

更致命的是，DNT会严重影响Online behavioral advertising （OBA）的运营和收入。为什么Google，FB， amazon，being等广告大户从不支持DNT？其中官方的解释“用户并不完全理解和明白DNT的含义”是有一定道理的。更重要的是，谁也不愿意拿出到手的肥肉——OBA的运营收入作为”更好的尊重用户隐私“的代价。

国内的广告平台和tracking service更为混乱和初级，所以单就国内用户而言，开不开DNT基本感受不到任何差别，因为现阶段支持DNT的网站太少了。。在国外，已经有部分广告平台声明支持DNT，甚至包括twitter（但twitter只在部分功能上支持DNT）。当支持DNT的网站仍为少数。

DNT的发展面临着巨大的阻力和困难。技术和政治不能相提并论。只能说DNT是W3C的一个美好愿景和初级尝试。至于如何真正更好的保护用户隐私，DNT绝对不会是最终答案。

赞同：55

评论：4

如何成为一名真正的程序员？

wsivoky

,

⎝≧⏝⏝≦⎠

这很容易，又很困难。

算法、语言等当然很重要，但更重要的是这个：

Write Code Every Day

（翻译：每天写代码）

“每天”在我看来之所以重要，有两个原因：

1. 坚持训练自己

2. 承诺这是每天必做之事，真正认为这对你是至关重要的

请老实地告诉我，除了吃饭拉屎等生理上的必须，和上班打卡对老板微笑等社会上的必须之外，你每天在坚持自己的什么？

真正的程序员并不比其他任何人，比如真正的作家、画家，或者搬砖工人更特别，这只是一件事情，关键在于，你是否由衷地热爱，并用行动在坚持。

这张图表示迄今为止，John Resig 坚持了 204 天（半年多），每天写代码。

写代码也许太困难太专业，但你能坚持半年每天早上起来叠被子么？我坦白我试过，满地打滚地做不到好男人。虽然我认为不叠被子有太多好处。

这是成为真正的任何人的必经之路。包括 —— who wants to be a real programmer.

----

* 不知道 John Resig 是谁，自己去搜索

赞同：54

评论：7

前端是个大坑么？

墨磊

,

不折腾会死星人 // github.com/morlay

还没毕业吧 ？那急个啥。

与其去笔试面试，还不如折腾出点成品，

实习只不过学习途径之一，

至于机会是否有，取决于自己准备了多少。

而题目，

前端确实是个大坑。

如果不能坚持的不断学习，这个坑还是别跳了。

另，不要浮躁。

怎么做？

做 Demo

比如 效仿

Codrops

理解好每一句代码的作用，当然这上面的例子很多是超前的，

不一定能完全用到生产中，但能学到很多。

又，

HTML5 Rocks - A resource for open web HTML5 developers

再又，

Learn HTML5, CSS3, Javascript

……

先实践，而后不懂的地方再去查阅手册，如

Doc Center | MDN

不用强求自己什么都要记住，什么都要刨根问底，这行业变化太快。

当然也有不变的地方，计算机方面的经典读物还是要抽时间看看的，

例如

《算法导论》

《设计模式》（作为参考书放一边，因为前端太多的开源类库用到了其提到的各种模式）

免费的托管方案

http://pages.github.com/

&&

https://drive.google.com/

前者，写自己的博客，顺便通过折腾 jekyll 理解 HTML 模版

后者，托管各种 Demo，至于怎么用，

请自行 Google，因为 「会 Google」 是码农必备能力。

最后，关于实习，或者说就业，

做点东西出来，总会有人看上的。

而等着别人来手把手教，

对不起，没人会有那么时间，特别是苦逼的码农，

更没有任何义务。

都来实习了，自然得是员工待遇，而不只是个学生。

平台可提供，其他的，看

个人兴趣

与

自我管理

。

但是，请折腾点东西，让人看到这两点。

赞同：50

评论：7

消灭星星（Popstar）游戏是怎么开发实现的？难不难？

左文

,

游戏开发者， CocosEditor

@谢邀

这是我在知乎第二次认真回答问题，第一次给了

开发一个 Flappy Bird 需要多少行代码，多少时间？

效果还不错。

首先表明我是一个代码帝，喜欢用代码说话，轻砸。

开发这样的游戏难不难，我觉得不难，

玩通关比开发难多了

，我一个礼拜才玩到第五关，开发两天就够了.

有图有真相，我开发过

逻辑实现

基本的流程就是这样 创建10*10随机星星——触摸——检测颜色——消除星星——掉落移动——合并星星——检测死局——结束 大概如此

代码实现是基于js编程语言，cocos2d-x游戏引擎实现的.

1 创建随机单个星星，并加入单个星星掉落动画

MainLayer.prototype.getRandomStar = function (colIndex, rowIndex) {    this.starSize = 72.    var stars = PS_MAIN_TEXTURE.STARS.    var randomStar = stars[getRandom(stars.length)].    var starSprite = cc.Sprite.createWithSpriteFrameName(randomStar).    starSprite.setAnchorPoint(cc.p(0.5, 0.5)).    starSprite.setPosition(cc.p(36 + colIndex * this.starSize,        1300)).    starSprite.starData = {name: randomStar, indexOfColumn: colIndex, indexOfRow: rowIndex}.    starSprite.setZOrder(100).    var flowTime = rowIndex / 10.    var fallAction = cc.MoveTo.create(flowTime, cc.p(36 + colIndex * this.starSize,        36 + rowIndex * this.starSize)).    starSprite.runAction(fallAction).    return starSprite.}

2 根据表格位置初始化10*10星星群，产生星星从空中坠落的效果

MainLayer.prototype.initStarTable = function () {    this.starTable = new Array(this.numX).    for (var i = 0. i < this.numX. i++) {        var sprites = new Array(this.numY).        for (var j = 0. j < this.numY. j++) {            var pSprite0 = this.getRandomStar(i, j).            if (pSprite0 != null) {                this.rootNode.addChild(pSprite0).            }            sprites[j] = pSprite0.        }        this.starTable[i] = sprites.    }}

3 10*10星星群检测触摸事件，通过this.sameColorList.length可以判断是第一次触摸还是第二次触摸 .数组长度 >1表示第二次触摸，这里又有分支，触摸的是刚才同一颜色区域还是其他区域？如果是原来颜色区域，删除this.removeSameColorStars()，如果不是原来颜色区域，恢复原状，然后新的检测.数组长度 <=1表示第一次触摸 直接检测颜色相同区域

MainLayer.prototype.onTouchesBegan = function (touches, event) {    var loc = touches[0].getLocation().    this.ccTouchBeganPos = loc.    for (var i = 0. i < this.starTable.length. i++) {        var sprites = this.starTable[i].        for (var j = 0. j < sprites.length. j++) {            var pSprite0 = sprites[j].            if (pSprite0) {                var ccRect = pSprite0.getBoundingBox().                if (isInRect(ccRect, this.ccTouchBeganPos)) {                    if (this.sameColorList.length > 1) {                        if (this.sameColorList.contains(pSprite0)) {                            cc.AudioEngine.getInstance().playEffect(PS_MAIN_SOUNDS.broken, false).                            this.removeSameColorStars().                        } else {                            for (var k = 0. k < this.sameColorList.length. k++) {                                if (this.sameColorList[k]) {                                    this.sameColorList[k].runAction(cc.ScaleTo.create(0.1, 1)).                                }                            }                            this.checkSameColorStars(pSprite0).                            if (this.sameColorList.length > 1) {                                cc.AudioEngine.getInstance().playEffect(PS_MAIN_SOUNDS.select, false).                            }                        }                    } else {                        this.checkSameColorStars(pSprite0).                        if (this.sameColorList.length > 1) {                            cc.AudioEngine.getInstance().playEffect(PS_MAIN_SOUNDS.select, false).                        }                    }                    break.                }            }        }    }}.

4 建立单个星星的四个方向检测，上下左右，把颜色相同的放在一个数组里面，回调这个数组.其实最后用这个函数的时候主要是判断数组的大小.数组大于1，说明四周有相同颜色的.

MainLayer.prototype.checkOneStarFourSide = function (sprite) {    if (sprite == null) {        return.    }    // cc.log("checkOneStarFourSide").    var fourSideSpriteList = [].    var color = sprite.starData.color.    var col = sprite.starData.indexOfColumn.    var row = sprite.starData.indexOfRow.    //up    if (row < 9) {        var upSprite = this.starTable[col][row + 1].        if (upSprite != null && upSprite.starData.color == color) {            fourSideSpriteList.push(upSprite).        }    }    //down    if (row > 0) {        var downSprite = this.starTable[col][row - 1].        if (downSprite != null && downSprite.starData.color == color) {            fourSideSpriteList.push(downSprite).        }    }    //left    if (col > 0) {        var leftSprite = this.starTable[col - 1][row].        if (leftSprite != null && leftSprite.starData.color == color) {            fourSideSpriteList.push(leftSprite).        }    }    //right    if (col < 9) {        var rightSprite = this.starTable[col + 1][row].        if (rightSprite != null && rightSprite.starData.color == color) {            fourSideSpriteList.push(rightSprite).        }    }    return fourSideSpriteList.}

5 检测相同颜色区域，这里的算法比较复杂.有两个数组this.sameColorList和newSameColorList，前者是全局星星数组，后者是每次扩展新加入的星星.比如这样情况，一个星星左右上有相同的星星，上面的上面还有一个星星，总共五个相同星星：三次检测情况是this.sameColorList为1---4----5 ，而newSameColorList为1--3--1，各种曲折，读者好好理解下.

MainLayer.prototype.checkSameColorStars = function (sprite) {    if (sprite == null) {        return.    }    this.sameColorList = [].    this.sameColorList.push(sprite).    var newSameColorList = [].    newSameColorList.push(sprite).    //by logic ,check the same color star list    while (newSameColorList.length > 0) {        for (var i = 0. i < newSameColorList.length. i++) {            var fourSide = this.checkOneStarFourSide(newSameColorList[i]).            if (fourSide.length > 0) {                for (var j = 0. j < fourSide.length. j++) {                    if (!this.sameColorList.contains(fourSide[j])) {                        this.sameColorList.push(fourSide[j]).                        newSameColorList.push(fourSide[j]).                    }                }            }            newSameColorList.splice(i, 1).        }    }    cc.log("sameColorList length==" + this.sameColorList.length).    if (this.sameColorList.length > 1) {        for (var k = 0. k < this.sameColorList.length. k++) {            var simpleStar = this.sameColorList[k].            if (simpleStar) {                simpleStar.runAction(cc.ScaleTo.create(0.1, 1.08)).            }        }    }}

6 移除刚才选中的相同颜色的星星，并产生爆炸粒子效果

MainLayer.prototype.removeSameColorStars = function () {    for (var k = 0. k < this.sameColorList.length. k++) {        var simpleStar = this.sameColorList[k].        if (simpleStar) {            var col = simpleStar.starData.indexOfColumn.            var row = simpleStar.starData.indexOfRow.            this.starTable[col].splice(row, 1, null).            this.rootNode.removeChild(simpleStar).            if (sys.platform != 'browser') {                var starParticle = cc.StarParticle.create(this.rootNode, (36 + col * this.starSize), (36 + row * this.starSize), "spark").                starParticle.runAction(cc.Sequence.create(cc.DelayTime.create(0.8), cc.CleanUp.create(starParticle))).            }        }    }    this.sameColorList = [].    this.fallStar().}

7 星星掉落 填充空缺，主要是如果一个地方有空缺，就把它上面的星星位置和数据交换，用到数组的方法splice，可到网上查看js数组的一些方法应用

MainLayer.prototype.fallStar = function () {    for (var i = 0. i < this.starTable.length. i++) {        var sprites = this.starTable[i].        var length = sprites.length.        for (var j = 0. j < length. j++) {            var pSprite0 = sprites[j].            if (pSprite0 == null) {                var k = j + 1.                while (k < length) {                    var upSprite = sprites[k].                    if (upSprite != null) {                        upSprite.starData.indexOfColumn = i.                        upSprite.starData.indexOfRow = j.                        this.starTable[i].splice(j, 1, upSprite).                        this.starTable[i].splice(k, 1, null).                        k = length.                        var flowTime = 0.2.                        var fallAction = cc.MoveTo.create(flowTime, cc.p(36 + i * this.starSize,                            36 + j * this.starSize)).                        upSprite.runAction(fallAction).                    }                    k++.                }            }        }    }    this.deadStar().    // this.combineStar().}

8 合并星星，如果最底部有空缺，星星必须向左合并，不能出现空缺

MainLayer.prototype.combineStar = function () {    for (var m = 0. m < this.starTable.length. m++) {        var mSprite0 = this.starTable[m][0].        if (mSprite0 == null) {            if (m == (this.starTable.length - 1)) {                for (var j = 0. j < this.starTable[m].length. j++) {                    this.starTable[m].splice(j, 1, null).                }            }            else {                for (var i = (m + 1). i < this.starTable.length. i++) {                    // this.starTable.splice((i - 1), 1, this.starTable[i]).                    for (var j = 0. j < this.starTable[i].length. j++) {                        var pSprite0 = this.starTable[i][j].                        this.starTable[i - 1].splice(j, 1, pSprite0).                        if (pSprite0 != null) {                            pSprite0.starData.indexOfColumn = (i - 1).                            var col = pSprite0.starData.indexOfColumn.                            var row = pSprite0.starData.indexOfRow.                            var moveAction = cc.MoveTo.create(0.1, cc.p(36 + col * this.starSize,                                36 + row * this.starSize)).                            pSprite0.runAction(moveAction).                        }                    }                }            }        }    }    this.deadStar().}

9 游戏到最后 会发生死局情况，程序自动判断消除.这里主要是循环检测每一个星星，如果所有的星星四周都没有相同星星的时候，就确认为死局，程序自动消除星星

MainLayer.prototype.deadStar = function () {    var isDead = true.    for (var i = 0. i < this.starTable.length. i++) {        var sprites = this.starTable[i].        var length = sprites.length.        for (var j = 0. j < length. j++) {            var pSprite0 = sprites[j].            if (pSprite0 != null) {                if (this.checkOneStarFourSide(pSprite0).length > 0) {                    isDead = false.                    return.                }            }        }    }    if (isDead) {        for (var jj = 9. jj >= 0. jj--) {            for (var ii = 0. ii < 10. ii++) {                var pSprite0 = this.starTable[ii][jj].                if (pSprite0 != null) {                    var delay = 4 + 0.3 * ii - 0.4 * jj.                    pSprite0.runAction(cc.Sequence.create(                        cc.DelayTime.create(delay),                        cc.CleanUp.create(pSprite0)                    )).                    var starParticle = cc.StarParticle.create(this.rootNode, (36 + ii * this.starSize), (36 + jj * this.starSize), "spark").                    starParticle.runAction(cc.Sequence.create(cc.ScaleTo.create(0, 0),                        cc.DelayTime.create(delay), cc.ScaleTo.create(0, 1), cc.DelayTime.create(0.8),                        cc.CleanUp.create(starParticle))).                }            }        }    }}

基本就是这样

想要源码到我博客里面找吧

：

http://blog.csdn.net/touchsnow/article/category/2094455

赞同：43

评论：7

如何提高编程能力？

vczh

,

专业造轮子 www.gaclib.net

初学者实现一下正则表达式引擎，对各种能力都有极大的帮助。算法不明白的话可以看我5年前写的两篇广为传播的文章：

《构造正则表达式引擎》新鲜出炉啦！

，实在不知道怎么实现的可以看我的代码：

https://gac.codeplex.com/SourceControl/latest#Common/Source/Regex/Regex.h

（不过也没指望连思考都没有过的人可以看明白）。当然如果你们先看了我的代码再自己实现的话，效果会大打折扣。

赞同：43

评论：11

Python 常用的标准库以及第三方库有哪些？

yegle

,

野生程序猿

只介绍我用过觉得有强烈推荐欲望的几个

=====================标准库

*

http://docs.python.org/library/argparse.html

写命令行脚本必备，可惜是2.7才添加的，得看具体环境了…

*

http://docs.python.org/library/htmlparser.html

解析HTML DOM树，偶尔搞搞命令行自动表单提交用得上。感觉不好用但是毕竟是官方库

=====================第三方库

*

http://pypi.python.org/pypi/sh

简直是系统管理神器，谁用谁知道

*

http://pypi.python.org/pypi/suds

轻量的SOAP客户端，如果贵厂内部有用SOAP接口，那这个几乎是必须了

*

http://pypi.python.org/pypi/requests

这个HTTP lib的名字叫Python HTTP for Human。用过urllib、urllib2、httplib的人，你懂的

*

http://pypi.python.org/pypi/pelican

*

http://pypi.python.org/pypi/Markdoc

前者是静态博客生成器（写markdown文本，然后自动转换成html静态文件），后者是文档生成器（以前拿这个做wiki用）

*

http://pypi.python.org/pypi/pep8

检查Python脚本是否符合PEP8的style guide

*

http://pypi.python.org/pypi/Pygments

语法高亮的lib，很多ruby项目用的都是这个python lib来做语法高亮的

其他想到了再补充吧

赞同：40

评论：4

在 GitHub 上看到过的最有意思的项目是什么？

匿名用户

Avida：

https://github.com/devosoft/avida

一个有关人工生命的实验，相关论文曾发表在Nature上。

是美国密西根大学做的一个在内存里验证和研究进化论的模拟器。

相关的论文也很有意思，中心思想是让程序进化以完成一些比较复杂的操作，可以自己跑一些case，通过进化得出的对问题的解决方案的奇妙程度绝对能震惊到每一个看懂的人。看完后感觉自然内在蕴含的创造力实在太令人惊叹了。（而且每次跑出的解决方案还都不一样）

赞同：37

评论：10

在平板电脑（iPad / Android Pad）上写代码有什么样的靠谱的方案？

imlk

,

头像非本人

强力推荐iPad上的Textastic这个神器。第一次使用就被震撼了，用了一年多，感觉没有比它更适合在iPad上写代码了。

说说其中几个优点：(图片均来自网络，懒得自己截图了）

1. 支持识别80多种编程语言的语法，其中包括 HTML, XML, Markdown, Objective-C, C++, PHP, Perl, Python, SQL, JavaScript, CSS, shell scripts，当然也包含你所提到的Lua。（完整支持列表在这里：

Which file types are supported?

）

2. 代码自动补全提示，支持 HTML, CSS, JavaScript and PHP。

3. 强大的文件共享和传输。支持FTP, FTPS, SFTP (SSH connection), WebDAV，还有很重要的，支持从Dropbox下载。另外文件还可以通过电邮发送，通过电脑上的iTunes来管理，或者通过其他软件里面的"Open in"按钮来读取。

4. 强大的内置虚拟键盘和游标控制，以及对外置蓝牙键盘的支持。

5. 方便的查找，替换，。。。

6. 各种字体，设置。。。

iPhone和iPad版是分开的，每个$8.99, 我买的时候还是$9.99.

刚发现居然还出了Mac版，$5.99.

iTuens链接：

https://itunes.apple.com/us/app/textastic-code-editor/id383577124?mt=8

官网：

Textastic - Text, Code and Markup Editor with Syntax Highlighting

最后奉劝一句，Macbook Air才是正道。

赞同：35

评论：10

用 Vim 写 Python 的最佳实践是什么？

李继刚

,

www.lijigang.com

直接空白Vim使用 John Anderson 的配置就行了

Turning Vim into a modern Python IDE

鏈接：

http://sontek.net/turning-vim-into-a-modern-python-ide

附上我的Vim截圖一張：

赞同：34

评论：9

为啥 redis 使用跳表(ziplist)而不是使用 red-black？

dccmx

,

IT、互联网、搞技术的

redis使用跳表(ziplist)?

首先，跳表是skiplist？不是ziplist。ziplist在redis中是一个非常省内存的

链表

（代价是性能略低），所以在hash元素的个数很少（比如只有几十个），那么用这个结构来存储则可以在性能损失很小的情况下节约很多内存（redis是内存数据库啊，能省还是要省的）。好这个问题清楚了。

至于这个问题：

请问，有人用C实现过红黑树么？

实在看不懂。

========无敌的分隔线=======

不过提问者所引出的另一个问题倒是值得讨论一下，就是在server端，对并发和性能有要求的情况下，如何选择合适的数据结构（这里是跳跃表和红黑树）。

如果单纯比较性能，跳跃表和红黑树可以说相差不大，但是加上并发的环境就不一样了，如果要更新数据，跳跃表需要更新的部分就比较少，锁的东西也就比较少，所以不同线程争锁的代价就相对少了，而红黑树有个平衡的过程，牵涉到大量的节点，争锁的代价也就相对较高了。性能也就不如前者了。

不过这些对redis这个单进程单线程server来说都是浮云。

赞同：26

评论：5