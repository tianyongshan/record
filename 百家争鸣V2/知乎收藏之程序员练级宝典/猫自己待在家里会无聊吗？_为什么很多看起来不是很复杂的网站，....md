# 猫自己待在家里会无聊吗？_为什么很多看起来不是很复杂的网站，...

目录

猫自己待在家里会无聊吗？

为什么很多看起来不是很复杂的网站，比如 Facebook 需要大量顶尖高手来开发？

程序员有哪些借口可以让自己写出低质量的代码？

开发一个 Flappy Bird 需要多少行代码，多少时间？

程序员中的大牛都是从很早就开始接触编程的吗？

如何保存某位知乎用户的所有答案？

写一个 GoAgent 难度大吗？难在什么地方？

如何成为一个杰出的程序员？

如何成为一名数据科学家？

Python 爬虫如何入门学习？

程序员新人怎样在复杂代码中找 bug？

怎样成为全栈工程师（Full Stack Developer）？

显著提升程序员身心健康和工作效率的装备有哪些？

很多网站提供用微博和 QQ 账号登录，好处是什么呢？

写一个操作系统内核有多难？大概的内容、步骤是什么？

如何正确地使用设计模式？

怎么样才算是精通 Python？

为什么那么多人会喜欢编程，怎么进入那个状态的呢？

怎样使用 GitHub？

如何循序渐进有效学习 JavaScript？

为什么很多国内公司不使用 jQuery 等开源 JS 框架（库），而选择自己开发 JavaScript 框架？

知乎工程师们的开发环境是怎么样的？

怎么把知乎收藏夹下载下来做成电子书在手机上看？

微信扫描二维码登录网页是什么原理，前后两个事件是如何联系的？

机器学习该怎么入门？

国外知名 IT 企业是如何做测试的？

怎样才能加入到微信团队工作？

初学 Python，有哪些 Pythonic 的源码推荐阅读？

如何更有效地学习开源项目的代码？

为什么多 TCP 连接分块下载比单连接下载快？

虚拟机是怎么实现的？

Dalvik 虚拟机和 Sun JVM 在架构和执行方面有什么本质区别？

常见的网站服务器架构有哪些？

淘宝的评论归纳是如何做到的？

Leap Motion 的原理是什么？

怎么能够体会到 Google 的强大？使用时有什么技巧以及方法？

什么程序设计语言机制是处理异步 IO 最恰当的抽象？

在编程和算法领域，有哪些经典问题？

仅仅从好玩程度考虑，做编译器或操作系统哪个更有趣味？

互联网编程如何入门，学习路径大致是怎样的？

作为一名做 Web 开发的 Java 工程师，算法在工作中基本不怎么用到，但为什么面试总会问算法的问题？

可以用Python编程语言做哪些神奇好玩的事情？

有哪些适合程序员读的人文书籍？

技术人员在转向移动开发过程中有哪些经验和教训值得大家借鉴？

HTTPS 和 OpenSSL 是什么关系？

程序员该有哪些职业道德？

如何优雅地编程？

Python 在编程语言中是什么地位？为什么很多大学不教 Python？

Linux 内核的操作系统是不是得一直运行着？

如何衡量一个人的 JavaScript 水平？

如何通过模仿大师来学习计算机编程？

如何深入理解多进程，多线程，非阻塞/异步IO(callback) 以及Coroutine模型？

开启浏览器的「Do Not Track」后，会对浏览造成什么影响？

如何成为一名真正的程序员？

前端是个大坑么？

消灭星星（Popstar）游戏是怎么开发实现的？难不难？

如何提高编程能力？

Python 常用的标准库以及第三方库有哪些？

在 GitHub 上看到过的最有意思的项目是什么？

在平板电脑（iPad / Android Pad）上写代码有什么样的靠谱的方案？

用 Vim 写 Python 的最佳实践是什么？

为啥 redis 使用跳表(ziplist)而不是使用 red-black？

Lisp 解释器？

阿里巴巴有什么特别的公司文化？

程序员如何提高阅读理解代码的速度和能力？

Medium.com 的前端技术基于什么，有怎样的特点？

成熟的Web开发团队开发、测试、上线的环境和流程是怎样的？

如何写好技术文档？

面向对象中的依赖注入概念本质上是否与面向过程中的模块导入一致的？

豆瓣的书影音评分是如何计算的？

如何高效地实现函数式数据结构？

一名合格的前端工程师的知识结构是怎样的？

如何通过 GitHub 加入开源项目？

Online Judge 是如何解决判题端安全性问题的？

书上说C++是面对对象语言，这是什么意思？能举个好懂的例子吗

怎样看待下一代 ASP.NET 将全部开源，并同时支持 Windows，Linux 和 Mac？

如何面试前端工程师？

Summly 是怎么将一大段文本自动转换成摘要的？

学习编程能帮助提高逻辑思维能力么？

国外，前端领域有什么出名的论坛或者社区？

新浪微博授权为什么要设置时效？

猫自己待在家里会无聊吗？

GOUKI

,

猫仔是我的伙伴和朋友

要知道猫是不是无聊，你得有足够的观察，根据观察，将猫仔们的行为进行归类，进而得知猫无聊的表现是怎样的，然后才能知道猫仔白天是不是很无聊，有多无聊，有多少时间在无聊。

曾经有人问我“

你不在家的时候，猫在做什么

”，我发现，我居然

不知道。

但实际上，重点是：我怎么既不在家又能观察到猫独自在家时候的情况呢？

"白柔你附耳过来，我讲一个事情给你“

”什么“

”欠仔胖得跳不上沙发啦“

ZZZzzz... x 3

”什么声音！“

”来人，护驾！“

”吃，吃不下了！“

这只是积累下来的一天中的几个片段而已

你看，这对于我的好奇心无疑是一个折磨，同时也是对我能力的挑战！

于是我毫不犹豫从极低的水准开始边学边做，用了近三个月的工余时间，购买必要的设备，组装，调试，写脚本，最终完成了一套

3摄像头全景观察系统和

一台wifi小车

移动摄像

，利用现学粗浅的linux技术，实现了对家里的

全方位

观察，并利用Motion和外挂usb储存，对所有的猫的

动态进行抓图存储

和自动时间排序归档，以及通过互联网实现即时观察和远程操作。

我就不放家里的建筑结构图和摄像头视角覆盖visio图了……3点覆盖原理，基本可以夸称

无死角

感谢

@zeg

全程给予无私的技术支持，在opwrt系统方面如果没有他我不可能独立完成这些内容。

基本构建：双openwrt路由器分别挂载720p自动对焦摄像头，A B1 B2，通过桥接连接，通过端口映射完成外网直接访问，各自挂载移动硬盘作为系统和储存设备，限于ADSL上传带宽有限，视频质量为360p，5fps，高压缩比，M-jpeg视频流，通过chrome等浏览器可以直接观察，ie需要加插件。

图像储存和远程控制通过动态域名和www服务浏览器直接接入或用ssh访问。

小车：自制小车一台，路威一台，下有说明

这就是大数据的一部分了：

图中是1月14日中，所有摄像头A捕捉的猫动态截图的一部分，任取一个例图如下

可命名为

柔仔矫健跳上凳子图1

，灰色方块代表动作捕捉

自动标注区域

，右下是时间。

同理每天还会看到灰仔大爷吃饭图1，大家一起吃饭图2，欠仔出恭图1,2，灰仔柔仔玩闹图1等等等。

图片每天通过一个crontab自动归档，如果有定义为异常的动作会直接发邮件到gmail提醒我（这个异常主要是指比如大门在我上班的时间有开关，权当防盗，我家没什么值钱东西，除了猫仔们）。

每15分钟会自动检查和更新动态域名，检查摄像头程序状态，防僵死和自动拉起。

----摄像头B1/B2，可切换-----------摄像头A----------

↓↓ ↓↓

↑↑

------路威操作界面，我说过这家伙还有-

避障雷达

吗？

我可以

随时在任何有网络的地方

，用各种电脑平板手机PSP，打开

上述页面

通过三视角摄像头观察家里猫的动态，也可以开

Rovio™ - WowWee®

小车和他们进行一下简单的互动——其实是”好可怕这是什么“——”这破玩意又动起来了“——”那个白痴又在偷看了吧“的三个不同阶段。

写到这里也不好意思不给

路威君

一个广告：性价比绝高的动态Webcam解决方案。小车自带摄像头，角度可调，还有音频交互，能够利用民用版北极星系统，根据红外投影自动寻路回去充电，用万向轮进行全角度移动，自带头灯（之前自己做了一个小车简陋的多，但也有高清摄像头和自动充电），是一个完美的独立全角度观察系统，支持动态域名，支持用户权限调整，等等。

好吧，于是我近乎痴迷的，每天在工作之余开着远程页面观察猫仔们的动作，甚至傻乎乎的看猫在阳光下睡觉看一中午。或者没事就去翻最近一周一个月的图片看看猫仔们都在每天的什么时间作什么。

---------------------------

结论出现

的分割线------------------------

经过长达700多天的媒体数据积累和大量的观察事实统计，我只能得出以下几个相对可靠的结论：

1，猫仔们每天白天的

大多数时间在睡觉

，没有做过详尽统计，但是大约是上班12小时中的约9-10小时

2，猫仔们的行动

有规律可循，

以欠仔为例，每天下午14点左右吃饭喝水的时间误差平均不到5分钟，不同季节都很准确

3，猫仔们的互动很少，呈现显著的

地域性，

即使在我狭小的50平米小公寓内，也有鲜明的区域划分，例如猫爬架的最上层永远是灰仔专属，猫窝基本是柔仔专属等等

4，猫仔们的互动有

一定的阶级性

，岁数最大的柔仔会给灰仔和欠仔舔毛，这点是我在新浪微博的@十四阙 的提示下注意到的——虽然听起来很奇怪，但是确实如此，负责给其他猫舔毛的反而是地位最高的那位

5，猫仔们

对你的迎接不代表长时间的等待

：柔仔和灰仔几乎次次会在我回家的时候在门口等待，但是我超过5次悄悄摸到门外连上wifi打开手机看到的都是她们该干嘛干嘛，听到我的脚步和钥匙响才会跑到门口。

6，不限于现在养的猫，范围放大而言，猫的

性格差异巨大，

有的猫总是在固定范围逡巡，有的猫活动范围大到方圆近10平方公里.有的猫体现出强烈的攻击性，有的猫则表现极为温顺.有的猫会完全不能和其他猫和平相处，有的猫则在近乎群居的环境下和其他猫相处融洽。

7，独自在家的猫仔除了互动方面，其他和群居时

没有太显著的差异

。

8，长期观察

破除了

猫会趁你不在的时候偷喝你的啤酒，偷用你的电脑下毛片，偷偷试穿你的衣服等

江湖传言

9，

也没有任何对比可以证明

我的存在对猫的生活行为有显著影响

，——当然除去必要且规律的的“去清扫猫砂啊笨蛋“”该吃饭了啊笨蛋“”不要占我的位置啊笨蛋“”太吵了啊笨蛋“之外的话

X，基于量子不可测性，我无法排除“

所有的我观测到的情形都是在喵星人已知被观测的情形下故意表现出来的

”这一可能

-------------------------------以上等于都没说的分割线----------------------------

所以啊，我不在家的时候，猫会不会无聊我不太知道，但是无聊的时间恐怕也不会太多，除非睡觉时也在作无聊的梦吧.有的猫的“无聊”的表现也许是发呆，有的猫的“无聊”的表现也许是再吃一顿加餐，有的猫的“无聊”的表现也许是去抓小鸟……谁知道呢

子非猫，安知猫无聊不无聊。

至于

猫和主人的关系是怎样

，我赞同上面的结论，猫有优越的独立性，她们会把我看做一个能够提供食物的好伙伴，但是不会把我当做首领或者可以依赖的对象

哦又跑题了。

赞同：5113

评论：433

为什么很多看起来不是很复杂的网站，比如 Facebook 需要大量顶尖高手来开发？

子柳

,

重度网瘾患者，尚未放弃治疗

就拿淘宝来说说，当作给新人一些科普。

先说你看到的页面上，最重要的几个：

【搜索商品】——这个功能，如果你有几千条商品，完全可以用select * from tableXX where title like %XX%这样的操作来搞定。但是——当你有10000000000（一百亿）条商品的时候，任何一个数据库都无法存放了，请问你怎么搜索？这里需要用到分布式的数据存储方案，另外这个搜索也不可能直接从数据库里来取数据，必然要用到搜索引擎（简单来说搜索引擎更快）。好，能搜出商品了，是否大功告成可以啵一个了呢？早着呢，谁家的商品出现在第一页？这里需要用到巨复杂的排序算法。要是再根据你的购买行为做一些个性化的推荐——这够一帮牛叉的算法工程师奋斗终生了。

【商品详情】——就是搜索完毕，看到你感兴趣的，点击查看商品的页面，这个页面有商品的属性、详细描述、评价、卖家信息等等，这个页面的每天展示次数在30亿以上，同样的道理，如果你做一个网站每天有10个人访问，你丝毫感觉不到服务器的压力，但是30亿，要解决的问题就多了去了。首先，这些请求不能直接压到数据库上，任何单机或分布式的数据库，承受30亿每天的压力，都将崩溃到完全没有幸福感，这种情况下要用到的技术就是大规模的分布式缓存，所有的卖家信息、评价信息、商品描述都是从缓存里面来取到的，甚至更加极致的一点“商品的浏览量”这个信息，每打开页面一次都要刷新，你猜能够从缓存里面来取吗？淘宝做到了，整个商品的详情都在缓存里面。

【商品图片】——一个商品有5个图片，商品描述里面有更多图片，你猜淘宝有多少张图片要存储？100亿以上。这么多图片要是在你的硬盘里面，你怎么去查找其中的一张？要是你的同学想拷贝你的图片，你需要他准备多少块硬盘？你需要配置多少大的带宽？你们的网卡是否能够承受？你需要多长时间拷贝给他？这样的规模，很不幸市面上已经没有任何商业的解决方案，最终我们必须自己来开发一套存储系统，如果你听说过google的GFS，我们跟他类似，叫TFS。顺便说一下，腾讯也有这样的一套，也叫TFS。

【广告系统】——淘宝上有很多广告，什么，你不知道？那说明我们的广告做的还不错，居然很多人不认为它是广告，卖家怎么出价去买淘宝的广告位？广告怎么展示？怎么查看广告效果？这又是一套算法精奇的系统。

【BOSS系统】——淘宝的工作人员怎么去管理这么庞大的一个系统，例如某时刻突然宣布某位作家的作品全部从淘宝消失，从数据库到搜索引擎到广告系统，里面的相关数据在几分钟内全部消失，这又需要一个牛叉的后台支撑系统。

【运维体系】——支持这么庞大的一个网站，你猜需要多少台服务器？几千台？那是零头。这么多服务器，上面部署什么操作系统，操作系统的内核能否优化？Java虚拟机能否优化？通信模块有没有榨取性能的空间？软件怎么部署上去？出了问题怎么回滚？你装过操作系统吧，优化过吧，被360坑过没，崩溃过没？这里面又有很多门道。

不再多写了，除了上面提到的这些，还有很多很多需要做的技术，当然并不是这些东西有多么高不可攀，任何复杂的庞大的东西都是从小到大做起来的，里面需要牛叉到不行的大犇，也需要充满好奇心的菜鸟，最后这一句，你当我是别有用心好了。

赞同：3924

评论：193

程序员有哪些借口可以让自己写出低质量的代码？

匿名用户

我很久很久以前曾经经历的一个公司特别傻比，人力资源和svn管理员不懂程序。

作为服务端的主程序，一直以来都是代码精简，效率最优，没有冗余为毕生追求。

突然我无意中发现了一个秘密，我的绩效居然不如几个公司刚招进来的新手。

我每天刻苦努力，优化代码，让公司的服务端7*24稳稳跑在服务器上，还一心研究各种热切换，换来绩效考核好久没有优秀了。

这究竟是为什么呢，后来好心人告诉我，人力资源说了，他们看了svn的日志记录，其他人工作很努力，每天提交很多代码，每天新编写很多很多代码文件，贡献了好多好多的劳动成果。

而看看你这个号称技术排第一的家伙，根本就没干活嘛，3个月下来，你一共就写了这么十来个cpp和.h，每天改来改去就这么几个文件，还好多天差不多行数的位置回改，根本就一直在偷懒。

我听完以后以后直接口吐鲜血，无语至极了。

然后我就申请离职了，在那个公司剩下不多的日子了，我为了心安理得的拿最后2个月的工资，为了让老板知道其实我一直很努力，我在最后一个月更新了几千个文件，让服务端的内核稳定度下降了好几个档次，内存消耗上涨了好多个数量级，并且把容易读，容易后续扩展的部分，全部用c++最高级的模版进行扩展，同时删掉了我以前用汇编写的优化代码。

嗯，我想以后这个公司估计会倒闭，我走了以后，再也没有人能维护这份代码了，估计3个月以后，我自己也搞不定了。

然后我就离职了，离职之前老板大夸我厚道，最后一个月还给公司做了这么多的事情，别人走都是删代码，我居然还毫无保留的为公司做出贡献。

然后我走了不到半年，公司就呵呵了。

我想那是我此生唯一写垃圾代码写的心安理得的一次机会了。

赞同：3737

评论：844

开发一个 Flappy Bird 需要多少行代码，多少时间？

左文

,

游戏开发者， CocosEditor

网上找到一篇文章，主场景300左右行代码，一天时间做出来，你信么？

原文链接：

flappy bird游戏源代码揭秘和下载

————————————————————————————————————

背景：

最近火爆全球的游戏flappy bird让笔者叹为观止，于是花了一天的时间山寨了一个一模一样的游戏，现在把游戏的思路和源码分享出来，代码是基于javascript语言，cocos2d-x游戏引擎，cocos2d-x editor手游开发工具完成的，请读者轻砸.

ps：运行demo必须配置好cocos2d-x editor，暂不支持其他工具.

还有demo是跨平台的，可移植运行android，ios，html5移动系统等，csdn博客里会介绍代码如何移植，请持续关注.

Android Apk下载演示：

暂时先移植到android平台

下载地址：

http://share.weiyun.com/cac18d8c58d40bf2401b3fdeeb6bcb2f

代码下载：

csdn下载：

http://download.csdn.net/detail/touchsnow/6912707

百度云盘：

http://pan.baidu.com/s/1pJnWDb9

金山快盘 ：

http://www.kuaipan.cn/file/id_25348935635745384.htm?source=1

代码如何移植到各平台：

Android：

http://blog.csdn.net/touchsnow/article/details/19176091

html5:

http://blog.makeapp.co/?p=245

效果图：

开发工具：

cocos2dx editor，它是开发跨平台的手机游戏工具，运行window/mac系统上，javascript脚本语言，基于cocos2d-x跨平台游戏引擎, 集合代码编辑，场景设计，动画制作，字体设计，还有粒子，物理系统，地图等等的，而且调试方便，和实时模拟.

cocos2dx editor下载，介绍和教程：

http://blog.csdn.net/touchsnow/article/details/19070665

.

cocos2dx editor官方博客：

http://blog.makeapp.co/?cat=8

.

思路和源码：

1 场景设计MainLayer.ccbx，如下图.主要分三层，开始场景、主场景、游戏结束场景，通过显示隐藏控制三个场景的切换。

MainLayer.ccbx代码

<?xml version="1.0" encoding="UTF-8"?><Document        jsControlled="true"        jsController="MainLayer"        resolution="default"        >    <Resolutions>        <Resolution centeredOrigin="false" ext="iphone" height="1280" width="720" name="default" scale="1"/>        <Resolution centeredOrigin="false" ext="iphone" height="720" width="1280" name="default1" scale="1"/>    </Resolutions>    <Animations>        <Animation autoPlay="true"                   id="0"                   name="Default Timeline"                   length="10"                   chainedId="0"                   offset="0.0"                   position="0.0"                   resolution="30"                   scale="128">            <CallbackChannel>            </CallbackChannel>            <SoundChannel>            </SoundChannel>        </Animation>    </Animations>    <Layer            positionX="0" positionY="0.0"            sizeType="Percent"            width="100" height="100"            anchorPointX="0.5" anchorPointY="0.5" ignoreAnchorPoint="true"            scaleX="1" scaleY="1"            >      <Sprite positionType="LeftBottom" width="720.0" height="1280.0" positionX="0" positionY="0" anchorPointX="0"                                         anchorPointY="0" src="Resources/bg.png" name="" var="" target="None" scaleX="1" scaleY="1" visible="true"/>      <LayerColor positionType="LeftBottom" width="720" height="1280" positionX="0" positionY="0" anchorPointX="0"                  anchorPointY="0" color="#fff2e8ff" visible="false"/>      <Menu positionType="LeftBottom" width="40" height="40" positionX="356.0" positionY="237.0" anchorPointX="0.5"              anchorPointY="0.5" scaleX="2.4" scaleY="1.725">      </Menu>      <Sprite positionType="LeftBottom" width="840.0" height="281.0" positionX="0" positionY="0" anchorPointX="0"                                         anchorPointY="0" src="Resources/ground.png" var="ground" target="Doc"/>      <Node positionType="LeftBottom" width="40" height="40" positionX="800" positionY="250" anchorPointX="0"            anchorPointY="0" var="hoseNode" target="Doc">        <Sprite positionType="LeftBottom" width="86.0" height="60.0" positionX="-500" positionY="400" anchorPointX="0.5"                                         anchorPointY="0.5" src="Resources/flappy_packer.plist/bird3.png" var="test" target="Doc" visible="false"/>        <Sprite positionType="LeftBottom" width="86.0" height="60.0" positionX="-550" positionY="500" anchorPointX="0.5"                anchorPointY="0.5" src="Resources/flappy_packer.plist/bird1.png" var="bird" target="Doc" scaleX="1" scaleY="1" rotation="0" visible="true"/>      </Node>      <Node positionType="LeftBottom" width="40" height="40" positionX="303.0" positionY="500" anchorPointX="0.5"            anchorPointY="0.5" var="readyNode" target="Doc" visible="true">        <Sprite positionType="LeftBottom" width="508.0" height="158.0" positionX="95.0" positionY="584.0" anchorPointX="0.5"                                         anchorPointY="0.5" src="Resources/flappy_packer.plist/getready.png"/>        <Sprite positionType="LeftBottom" width="286.0" height="246.0" positionX="73.0" positionY="236.0" anchorPointX="0.5"                                         anchorPointY="0.5" src="Resources/flappy_packer.plist/click.png"/>      </Node>      <Node positionType="LeftBottom" width="40" height="40" positionX="300" positionY="500" anchorPointX="0.5"            anchorPointY="0.5" var="overNode" target="Doc" visible="true">        <Sprite positionType="LeftBottom" width="590.0" height="298.0" positionX="72.0" positionY="219.0" anchorPointX="0.5"                                         anchorPointY="0.5" src="Resources/flappy_packer.plist/base.png">          <Sprite positionType="LeftBottom" width="508.0" height="158.0" positionX="286.0" positionY="458.0" anchorPointX="0.5"                                         anchorPointY="0.5" src="Resources/flappy_packer.plist/gameover.png"/>        </Sprite>        <Menu positionType="LeftBottom" width="40" height="40" positionX="0" positionY="0" anchorPointX="0.5"              anchorPointY="0.5">          <MenuItem positionType="LeftBottom" width="290" height="176" positionX="-65.0" positionY="-92.0" anchorPointX="0.5"                    anchorPointY="0.5" normalImage="Resources/flappy_packer.plist/start.png" target="Doc" onClick="onStartClicked"/>          <MenuItem positionType="LeftBottom" width="290" height="176" positionX="230.0" positionY="-92.0" anchorPointX="0.5"                    anchorPointY="0.5" target="Doc" normalImage="Resources/flappy_packer.plist/grade.png" onClick="onGradeClicked"/>        </Menu>      </Node>    </Layer></Document>

2 代码编写MainLayer.js

首先，小鸟在向前飞，其实是底部的路和水管在向左移动，相对的你就感觉小鸟在向右飞了.路循环移动代码：

MainLayer.prototype.groundRun = function (){    var action1 = cc.MoveTo.create(0.5, cc.p(-120, 0)).    var action2 = cc.MoveTo.create(0, cc.p(0, 0)).    var action = cc.Sequence.create(action1, action2).    this.ground.runAction(cc.RepeatForever.create(action)).}

初始化高低不同的水管，每一关卡都由上下两水管和空隙组成。总长度相同，空隙也一定，随机取下面水管的长度，就形成错落有致的水管关卡.

MainLayer.prototype.newHose = function (num){    var hoseHeight = 830.    var acrossHeight = 300.    var downHeight = 100 + getRandom(400).    var upHeight = 1100 - downHeight - acrossHeight.    var hoseX = 400 * num.    var HoseName = FP_MAIN_TEXTURE.HOSE.    var ccSpriteDown = cc.Sprite.createWithSpriteFrameName(HoseName[0]).    ccSpriteDown.setZOrder(1).    ccSpriteDown.setAnchorPoint(cc.p(0, 0)).    ccSpriteDown.setPosition(cc.p(hoseX, 0)).    ccSpriteDown.setScaleY(downHeight / hoseHeight).    var ccSpriteUp = cc.Sprite.createWithSpriteFrameName(HoseName[1]).    ccSpriteUp.setZOrder(1).    ccSpriteUp.setAnchorPoint(cc.p(0, 0)).    ccSpriteUp.setPosition(cc.p(hoseX, downHeight + acrossHeight)).    ccSpriteUp.setScaleY(upHeight / hoseHeight).    this.hoseNode.addChild(ccSpriteDown).    this.hoseNode.addChild(ccSpriteUp).    this.hoseSpriteList.push(ccSpriteDown).    this.hoseSpriteList.push(ccSpriteUp).    return null.}

一开始进入游戏让底部路不断移动，初始化水管，显示准备游戏场景.

MainLayer.prototype.onEnter = function (){    cc.AnimationCache.getInstance().addAnimations("Resources/flappy_frame.plist").    this.groundRun().    this.ground.setZOrder(10).    this.birdReadyAction().    this.bird.setZOrder(20).    this.readyNode.setVisible(true).    this.overNode.setVisible(false).    for (var i = 0. i < 30. i++) {        this.newHose(i).    }}

点击屏幕，小鸟向上飞60dp,然后更快的速度下落（移动动画），同时闪动翅膀（帧动画）.

MainLayer.prototype.birdRiseAction = function (){    var riseHeight = 60.    var birdX = this.bird.getPositionX().    var birdY = this.bird.getPositionY().    var time = birdY / 600.    var actionFrame = cc.Animate.create(cc.AnimationCache.getInstance().getAnimation("fly")).    var flyAction = cc.Repeat.create(actionFrame, 90000).    var riseAction1 = cc.MoveTo.create(0.2, cc.p(birdX, birdY + riseHeight)).    var riseAction2 = cc.RotateTo.create(0, -30).    var riseAction = cc.Spawn.create(riseAction1, riseAction2).    var fallAction1 = cc.MoveTo.create(time, cc.p(birdX, 50)).    var fallAction2 = cc.Sequence.create(cc.DelayTime.create(time / 6), cc.RotateTo.create(0, 30)).    var fallAction = cc.Spawn.create(fallAction1, fallAction2).    this.bird.stopAllActions().    this.bird.runAction(cc.Spawn.create(            cc.Sequence.create(riseAction, cc.DelayTime.create(0.1), fallAction),            flyAction)    ).}

检测碰撞，如果小鸟碰到地面和水管，发生碰撞，这里碰撞直接用cocos2d-x 里面的图片和图片交叉函数 cc.rectIntersectsRect.

MainLayer.prototype.checkCollision = function (){    if (this.bird.getPositionY() < 60) {        cc.log("floor").        this.birdFallAction().        return.    }    for (var i = 0. i < this.hoseSpriteList.length. i++) {        var hose = this.hoseSpriteList[i].        if (!this.isInScreen(hose)) {            // continue.        }        if (cc.rectIntersectsRect(hose.getBoundingBox(), this.bird.getBoundingBox())) {            cc.log("hose positionX==" + hose.getBoundingBox().x).            cc.log("this.bird positionX==" + this.bird.getBoundingBox().x).            cc.log("i==" + i).            cc.log("birdFallAction").            this.birdFallAction().            return.        }    }}

碰撞后，小鸟先下落，游戏结束场景显示.

MainLayer.prototype.birdFallAction = function (){    this.gameMode = OVER.    this.bird.stopAllActions().    this.ground.stopAllActions().    var birdX = this.bird.getPositionX().    var birdY = this.bird.getPositionY().    var time = birdY / 2000.    this.bird.runAction(cc.Sequence.create(            cc.DelayTime.create(0.1),            cc.Spawn.create(cc.RotateTo.create(time, 90), cc.MoveTo.create(time, cc.p(birdX, 50))))    ).    this.overNode.setVisible(true).}

游戏的难度主要在于多个水管的移动，小鸟触摸动画，检测碰撞.

再次提示代码下载地址：

csdn下载：

http://download.csdn.net/detail/touchsnow/6912707

百度云盘：

http://pan.baidu.com/s/1pJnWDb9

金山快盘 ：

http://www.kuaipan.cn/file/id_25348935635745384.htm?source=1

楼下有求图片的，地址：

http://share.weiyun.com/d73228232bc0b1ff99f553afff58b7a2

更多内容：

http://blog.csdn.net/touchsnow/article/details/19071961

官方博客：

http://blog.makeapp.co/

联系笔者：

zuowen@makeapp.co （邮箱）

想了解其他游戏开发可关注：

消灭星星（Popstar）游戏是怎么开发实现的？难不难？经常看到有人玩这个，很好奇里面的逻辑，拜求高手解答！

附录：其他游戏例子学习

http://blog.csdn.net/touchsnow/article/details/19070665

.

赞同：1692

评论：138

程序员中的大牛都是从很早就开始接触编程的吗？

张韩

,

图像处理进行中

要成为优秀的程序员,没别的,就是干!!!!!

---------

程序员男友大半夜跟你papapa完后可以立即去写代码的有木有!!!!这不是充分提高时间的利用率吗?!! 这是多少次发生的场景好吗? %>_<%请不要同情我............

[附：确实也经常听到时间长短不能衡量一个人水平高低，也许你看24小时的书不如别人24分钟是渣是牛，未来见分晓。 但是我依旧想看到有人在为自己的梦想做着不懈的努力。 纵使是渣，至少我是个为了当大牛而付出过的渣~]

好吧,正常点. 男朋友,大二c/c++程序猿一枚,算是学院公认的牛人吧,(他总说自己还算不上,啧啧又谦虚) 也许在知乎上很多大神看起来不算什么,但也算个进取的例子吧

你能想象每次出去吃饭逛街,只要有空,那家伙都在拿着手机看文档吗?(因为守着我就得离开他那亲爱的大房--电脑,所以只能屈就手机)

永远在学习!!!(偷偷在网上把他暴露了,还好是侧面,就不马赛克了.进知乎就是被他引进来的.还好没有互相关注 哇哈哈)

浏览器里的书签没截图,那个记录更多,记录了他从初中开始看过的所有的对他与帮助的东西. 他就是我在图书馆的自动查询机器有没有,因为想要什么技术书籍,他就能立马说出位置编号,指哪打哪儿有没有!

这是他最近手机里的文档

这是他手机上的application,都是这些有木有(还有好多好多我都看不懂+_+)

明明说是我们爱情的blog,却成了他"好记性不如烂笔头"的驻地

下面的就不要提了!! 吃饭等座位看文档!骑自行车遛弯休息时看文档,买完零食后看文档!去北京玩儿要去书店看书........例子太多,就不勾起我的伤心往事了%>_<%

这家伙高中时每天课上看编程书籍,每天中午趁着午休跑出学校去网吧有木有! 玩游戏? no! 编程有木有!!! 哎 每次寒暑假完全不用担心他勾搭别的小女生,因为他每天的工作就是 看书编程稍带给我打电话%>_<%

做的最发指的事情就是动不动刷我的平板刷成linux原生系统,从此我再也点亮不了屏幕有木有!

虽说这家伙也是从小对编程有很大兴趣,但是,如果没有后天见缝插针的看书学习练习.也许成就不了他的现在吧 (说成就貌似有点早 ,不过我相信他!)

早起的鸟儿不一定有虫吃,不断追逐进步的鸟儿才有虫吃. 就像某家伙说:真是越学习越感觉自己low啊!

我家程序员会唱歌会吉他(组过乐队有没有，吉他手有没有) 日语也超棒(不知道学日语的目的是什么←_←) 修各种家电\(^o^)/

π_π突然感觉自己啥都不会呢，好伤心

-----------

这几天收到很多人的祝福,真的好开心的说.没想到在我看起来这些已经习以为常的事情,可以给大家带来那么多正能量. 那我就简单说说我们家程序员的"成长记录"吧~(@^_^@)~(快速搜寻大脑ing)

小学: 那时候家里穷啊,有电脑没网络,那个家伙就整天打开电脑,这点那点,(他说:所有有字的能看的他几乎都看了) 算是最初启蒙吧

初中:初一那年竟然看完 计算机组成原理 和 微计算机技术两本书(他妈妈大学是计算机系，家里这种书特别多),(想想我当时在看什么,貌似少女小说吧....⊙﹏⊙b汗) 受这个的启发,他就去新华书店买了自己的第一本<Visual Basic教程> ,这个应该算正式进入编程行列吧. 初二下学期呢就用lua语言写了他自己平生的第一个游戏的说 └(^o^)┘.初三的时候住宿,没有电脑,那家伙就在寝室在纸上写了他平生第一个8021单片机程序,当时无设备的说. (哪像现在,在实验室随便一个板子就可以说出型号和各种信息)

高中:高一的时候被老师带去参加竞赛了,也正是开始了他的C/C++之路(他最自豪的是叫自己c++程序员儿),貌似那时候他们学校第一次搞竞赛,老师也都没什么经验,所以当时的C# 和Java都是他自学后教老师的说,肿么可以这样~~ 那时候也看了第一本全英的书籍 OpenGL ES 编程指南(貌似是这个,记得不太清了) . 那时候啊,为了备战高考只能住宿,可是没电脑啊,所以每天中午不午休,他就跑去网吧写代码,那时候在网吧在同学当中都成了异类的说. 也是那时候开始接触图形学,数字图像处理 和视频解码之类的. 正因为这样,所以高考的时候正科分数低了,程序员就没进入自己理想的学校(还好这样,否则我们俩就碰不到啦!!~(@^_^@)~)

大学:这说都说不清了,看的东西学的东西做的东西,我都列不出来了,看类似于史蒂文的TCP APUE UNP 这类的厚书(我看着都头晕啊)也成习惯了.在学院实验室跟导师也在做着以太网吧啦吧啦(+﹏+)~的什么东西。 为了能够挣到年500K来养我(我是寄生虫啦啦啦啦),程序员儿他也找到了自己的未来方向:底层工作者~~ 搞linux嵌入式驱动开发,现在呢正在写嵌入式操作系统(导致我每次的作业都要写两份的说,因为得为他空出时间嘛,然后每次去上课都要帮他签到, ~~~~(>_<)~~~~ 一个人上课好孤单) 偶尔呢接活儿做网站来赚点给我的零花钱 哇哈哈 最近为了"生意"也开始PhoneGap研究 大学的其实真的列不出来,因为和他人相比自己还很有差距,所以更得抓住现在的时间机会努力练习成长.

曾经我问他，为什么你既然会一些东西不去像他人一样专注与多接一些简单易行的比如做网站啥的赚钱呢。 程序员儿说他要抓住在大学里能够专注于学习和扎实自己的时光，不能短浅了目光。 也许和很多人相比，他真的不算什么，甚至会有人对他啧啧不屑一顾，但是，在我心中，他很棒！

评论里有大神找到了我和程序员儿的驻扎地的说,也有人问人家的blog,最近好懒啊,一直没更新

程序员和小女生

这是我们的blog啦(明显是来推销博客的→_→) 大家别见笑,呀 要上课啦 先跑喽 下午回家带程序员儿正式见父母喽(虽说以前见过了的说)

赞同：1455

评论：364

如何保存某位知乎用户的所有答案？

姚泽源

,

被Unicode编码问题给气坏了= =

-

------------------2014年8月06日19:50:12补充 ---------------------

在网吧实验时发现部分XP系统可能会提示程序错误，原因是系统里面缺少必要的运行文件，安装对应版本的python2.7即可

电子书在苹果系统上的可能无法正常阅读，解决方案：移动端安装多看阅读即可解决，OS X系统需要安装Chrome浏览器然后在Chrome的应用商店里搜索Readium插件，使用插件即可打开（安装拓展需翻墙，翻墙软件地址:链接:

百度云 请输入提取密码

密码: 9uti）

下载电子书前请先在

@柠檬

分享的电子书库

百度云 网盘-一如那哀婉的脸的分享

中进行搜索，尽量不要使用软件进行下载，直接用软件对知乎服务器的压力实在是太大了，涵请配合：）

------------------2014年5月8日11:21:28update---------------------

功能列表：

能够保存多个 指定用户 / 收藏夹(公共收藏夹&私人收藏夹) / 话题精华 /专栏 的答案并输出为HTML网页文件与Epub电子书（专栏需要用单独的专栏版进行下载）

电子书中答案按照问题进行整合，问题按其下答案的总赞同数排序，专栏按发布日期倒序排列

当用户将答案标注为『禁止转载』时助手将不会读取该答案

跨平台，Windows用户直接运行知乎助手.exe/知乎助手专栏版.exe即可运行，Mac/Linux用户请参考下文中的教程运行『python源代码/运行用源代码』下的ZhihuHelp.py与ZhiHuEpub_Zhuanlan.py（非常简单）

增量更新。在每一次运行时程序会录入所有新增和修改过的答案，但不会把答案在数据库里删除，所以，利用这个程序可以实现对知乎答案的永久保存

自动检测更新

当程序出现错误崩溃退出时，会自动将错误报告信息写入

『错误信息_未能成功打开的页面.txt』文件中，可以把这个文件发给我(yaozeyuan93@gmail.com)

，助手会因您的反馈而变得更好~

感谢

@林西豪

、

@Molly麥

、

@刘三清

@官姚

@骆启明

@夏小山

的捐赠与

@李奥

的推荐，谢谢大家的认可！谢谢(∩_∩)

欢迎在评论串里提建议~

使用方法：

Windows用户：

收集 指定用户 / 收藏夹(公共收藏夹&私人收藏夹) / 话题精华 的答案：

把

知乎助手2014年8月6日.zip_免费高速下载

这个文件下载下来

解压到任意文件夹

把待读取的 用户知乎主页地址、收藏夹首页地址复制粘贴到文件夹中的ReadList.txt里并保存

双击运行知乎助手.exe，开始时会让输入最大线程数，建议输入10或更小的数（光缆用户请勇敢的敲进20）

运行完毕后生成的电子书与网页均在知乎答案集锦文件夹中，Epub格式的电子书可在刷完多看系统的Kindle上、手机多看客户端以及Chrome的

Readium

扩展上阅读

WinXP~Win8均能直接运行，不能运行请留言反馈。

Tips：

生成的电子书默认为带有图片，上网按流量计费的同学或者需要下载大收藏夹的同学可考虑使用无图版进行下载，使用前请把『电子书制作临时资源库』这一文件夹在程序目录中删除

『电子书制作资源文件夹』中的cover.jpg为电子书封面，可以把其他图片改成cover.jpg放在这个文件夹中更换图书封面

针对丢失图片的问题，可以通过设置线程数解决，建议线程数=使用迅雷下载1G以上文件时的稳定网速(kb/s)÷100x5，即100kb/s的网速环境设置成5，200kb/s设置成10，500kb/s设置成25，以此类推

当然，或许用迅雷直接下载图片然后放在『电子书制作临时资源库\知乎图片池』中效果更好~软件毕竟不是专业的下载软件嘛~嘿嘿。

图片下载列表在『电子书制作临时资源库』中，使用迅雷的批量下载功能即可

鉴于源代码已经超过了1500行，所以就不放在这儿了~，

GitHub地址:

YaoZeyuan/ZhihuHelp__Python · GitHub

Kindle用户可以通过刷多看系统解决不能读取Epub文件的问题，非常简单

在官网上下载多看系统并根据要求放入Kindle中

打开Kindle点按菜单

重启，完成

非常不推荐使用mobi转换工具将Epub转换成mobi

转换过程非常漫长而且没有进度指示（在使用亚马逊官方转换工具的情况下）

丢失全部排版，当答案比较短时页面会变得掺不忍睹

刷多看又不麻烦为什么不用多看啊摔

好吧我是完美主义者

Mac/Linux用户（演示系统为Mac OS 10.9 64位/Ubuntu 12.04LTS）：

下载并解压

http://www.dwz.cn/zhihuhelp20140806

至任意文件夹（这里以桌面为例）

打开终端，输入 cd Desktop/ZhihuHelp2014年5月5日/python源代码

敲回车，如图

打开ReadList.txt，在把待下载的网址复制粘贴进去，然后保存，如图

回到终端，敲入 python2.7 ZhihuHelp.py（下载专栏时改为输入python2.7 ZhiHuEpub_Zhuanlan.py）

敲回车，等待运行完毕，over

（Mac连不上网。。。囧）

运行完成

若系统没有自带python2.7的Mac/Linux用户请自行百度如何安装python2.7

最后，程序已近完美，我也该休息一阵了，欢迎在评论串中提交功能建议和反馈bug

如果很喜欢这个程序的话，也可以用支付宝扫描下面的二维码向我捐赠，非常感谢~

赞同：1282

评论：432

写一个 GoAgent 难度大吗？难在什么地方？

Phus Lu

,

Geek, China

不难。

goagent 的原理用一句 python 代码就可以演示

urllib2.urlopen(urllib2.Request('

https://mail.google.com/fetch.py

', data='methd=GET&url=

http://twitter.com/&&body=

', headers={'Host': 'goagent.appspot.com'}))

好了，你现在有了一个托管在国外主机上的 WEB API，剩下的事情就是如何把它包装成一个本地代理了。

包装成 HTTP 代理也比较简单，借助 python 标准库的 SimpleHTTPServer/BaseHTTPHanlder 我们大约需要 500 行的 python 代码完成这个代理。

接下来的问题是大文件（视频）的支持和 HTTPS 的支持。

这个阶段你会遇到各种 HTTP/HTTPS 的细节问题，幸好我们完成了它，这时候代码增加到了 1000 行。

好了，现在现在我们可以让它真正开始工作了。需要处理各个平台 windows/macos/linux/android 的问题，还好大多数平台我们可以自己找到，并且修复在这些平台的 bug。代码中会增加 1500 行。

另外，我们还需要在各种浏览器下测试程序的行为，这时候程序 LOC 增长不会太大，但是解决这个兼容性问题会耗掉一些精力。

为了这个程序能够易用，我们需要在各个平台写个简单的 GUI 外壳，这需要我们懂 pyobjc/gtk/win32 等等支持。不过这个并不算难，折腾一番，我们也把这些外壳捣鼓出来了。此时代码已经大大膨胀了。

最后，用户会提出一些很合理的改进要求，比如 PAC/DNS/PHP 等等支持。嗯，加油做完这些，就差不多了。

好吧，如上述所示，goagent 的确没有特别的难点，我相信任何一个 python 程序员会在一个星期到一个月的时间内把它做出来。 :)

那么最后一个问题，

为什么各种软件中 goagent 相对比较受欢饮，它难在什么地方？

答案其实很简单：

热情和精力。

是的，有心做这个程序的人不少，尤其是程序员，对于开发一个自用的翻墙软件很多人有相当的兴趣。事实上也有不少这样的实现。

但是当用户提起 goagent 的评价是：“好用，快速，稳定，免费”。能够同时满足这些要求，goagent 花了不少心思。

好用：为了让 goagent 好用，需要学习不同平台和不同浏览器的特性，琢磨用户的用法，反复推敲功能的实现。

快速：为了能让 goagent 跑的更快，作者阅读 python 的标准库代码和 CPython 的实现，看完了 sildeshares 上的绝大部分关于 python 高效代码的方式和技巧。

稳定：Google 时常被干扰，如何优化连接方式是个永恒的话题，goagent 的连接方式前后一共改过三次。

免费：是的，如同

Goagent是怎么赢利的？

这个问题的最佳回答，我很赞同这个回答 "3、不是所有东西都是为了盈利才出现的"

关于 goagent 的更多可以参见

http://oschina.net/question/947559_117066

赞同：1278

评论：92

如何成为一个杰出的程序员？

李天放

,

课程格子团队工程师

我不能算是一个很优秀的程序员，但这个问题我已经反复思考了五年了。跟大家分享一下我的看法：

首先， 我认为答案绝对

不是

"只要写很多年代码就好了“。我面试过不少有10年经验，代码却写的很糟糕的程序员。经验很保贵， 但只靠经验是不够的。就像下棋一样，假如你用心研究，复习，不断挑战自己，也许可以成为一名大师。但不断用懒散的方式去玩棋，下20年也只是一个"臭棋篓子“。

我觉得比较有用的进步方式：

1. 学会看代码

大多数程序员都只愿意用自己写的代码，但高手一般可以轻易调用别人写的代码。表面看上去是工作习惯不同， 但实际上是能力上的差别。看代码要比写代码难很多倍。

我建议上班时多给队友们作code review，下班后试着阅读github上的开源代码。

2. 复习

程序员一般都很忙， 手上有永远也做不完的活儿。但在某些公司里， 你只是在反复做同样的事。偶尔放下手上的活儿，留下一部分时间来分析自己的弱点，更改坏习惯，看新书， 或学习新语言。

3. 做个人项目

工作中的编程一般只能让你熟悉一部分技术， 导致漏洞的形成。这就好像你长期一个人在自己后院练习投篮， 但第一次打比赛才（在惨败中）发些原来还需要传球， 防守， 强篮板这些概念。

Facebook喜欢雇佣所谓的 “full stack programmer”，就是一个人从设计，到交互，到html， css，javascript， server，sql， 架构，和数据统计都能做。成为full stack programmer最好的方式就是不断做个人项目。

4. 问答网站

问问题和回答问题都是很好的学习方式。 有的时候写出一个好问题， 比写出解答次问题所需要的代码还难。写问题可以帮你整理自己的思维逻辑。你可以试着每周在

http://stackoverflow.com

上问一个好问题或写一个好答案。

5. 加入一个好团队

最好的进步方式就是跟比自己强的人一起做事。高手都愿意聚在一起，所以很多会选择去优秀的早期创业公司。我在硅谷和创新工场创业时遇到了很多神人， 跟他们学了不少东西。

赞同：1197

评论：50

如何成为一名数据科学家？

Han Hsiao

,

一颗透明的心灵和会流泪的眼睛

-

版本更新，2014年5月14日更新一些内容。

-

如果展开讲，这个问题可以写一篇综述了。最近刚好有空，打算认真写写。

仅仅在几年前，数据科学家还不是一个正式确定的职业，然而一眨眼的工夫，这个职业就已经被誉为“今后十年IT行业最重要的人才”了。

一、数据科学家的起源

"数据科学"（DataScience）起初叫"datalogy "。最初在1966年由

Peter Naur

提出，用来代替"计算机科学"（丹麦人，2005年图灵奖得主，丹麦的计算机学会的正式名称就叫Danish Society of Datalogy，他是这个学会的第一任主席。Algol 60是许多后来的程序设计语言，包括今天那些必不可少的软件工程工具的原型。图灵奖被认为是“计算科学界的诺贝尔奖”。）

1996年，International Federation of Classification Societies (IFCS)国际会议召开。

数据科学

一词首次出现在会议（Data Science, classification, and related methods）标题里。

1998年，C.F. Jeff Wu做出题为“统计学=数据科学吗？ 的演讲，建议统计改名数据的科学统计数据的科学家。 （吴教授于1987年获得COPSS奖，2000年在台湾被选为中研院院士，2004年作为第一位统计学者当选美国国家工程院院士，也是第一位华人统计学者获此殊荣。）

2002年，国际科学理事会：数据委员会科学和技术（CODATA）开始出版数据科学杂志。

2003年，美国哥伦比亚大学开始发布数据科学杂志，主要内容涵盖统计方法和定量研究中的应用。

2005年，美国国家科学委员会发表了"Long-lived Digital Data Collections: Enabling Research and Education in the 21st Century"，其中给出数据科学家的定义：

"the information and computer scientists, database and software and programmers, disciplinary experts, curators and expert annotators, librarians, archivists, and others, who are crucial to the successful management of a digital data collection"

信息科学与计算机科学家，数据库和软件工程师，领域专家，策展人和标注专家，图书管理员，档案员等数字数据管理收集者都以可成为数据科学家。它们主要任务是："进行富有创造性的查询和分析。"

2012年，O'Reilly媒体的创始人

Tim O'Reilly

列出了世界上排名前7位的数据科学家。

Larry Page，谷歌CEO。

Jeff Hammerbacher，Cloudera的首席科学家和DJ Patil，Greylock风险投资公司企业家。

Sebastian Thrun，斯坦福大学教授和Peter Norvig，谷歌数据科学家。

Elizabeth Warren，Massachusetts州美国参议院候选人。

Todd Park，人类健康服务部门首席技术官。

Sandy Pentland，麻省理工学院教授。

Hod Lipson and Michael Schmidt，康奈尔大学计算机科学家。

具体有时间再补充，感兴趣的朋友可以

Google Scholar

一下他们的文献。

关于数据科学家的更多讨论：

你能列出十个著名的女性数据科学家吗？

Can you name 10 famous data scientist women?

谁是最富有的数据科学家？

Who are the wealthiest data scientists?

请列出对大数据最具有影响力的20个人？

Who Are The Top 20 Influencers in Big Data?

二、数据科学家的定义

数据科学(Data Science)是从数据中提取知识的研究，关键是科学。数据科学集成了多种领域的不同元素，包括信号处理，数学，概率模型技术和理论，机器学习，计算机编程，统计学，数据工程，模式识别和学习，可视化，不确定性建模，数据仓库，以及从数据中析取规律和产品的高性能计算。数据科学并不局限于大数据，但是数据量的扩大诚然使得数据科学的地位越发重要。

数据科学的从业者被称为数据科学家。数据科学家通过精深的专业知识在某些科学学科解决复杂的数据问题。不远的将来，数据科学家们需要精通一门、两门甚至多门学科，同时使用

数学，统计学和计算机科学

的生产要素展开工作。所以数据科学家就如同一个

team。

曾经投资过Facebook，LinkedIn的格雷洛克风险投资公司把数据科学家描述成

“能够管理和洞察数据的人”

。在IBM的网站上，数据科学家的角色被形容成

“一半分析师，一半艺术家”

。他们代表了商业或数据分析这个角色的一个进化。

for example – a data scientist will most likely explore and examine data from multiple disparate sources. The data scientist will sift through all incoming data with the goal of discovering a previously hidden insight, which in turn can provide a competitive advantage or address a pressing business problem. A data scientist does not simply collect and report on data, but also looks at it from many angles, determines what it means, then recommends ways to apply the data.

Anjul Bhambhri，IBM的大数据产品副总裁。

数据科学家是一个好奇的，不断质疑现有假设，能盯着数据就能指出趋势的人。这就好像在文艺复兴时期，一个非常想为组织带来挑战并从挑战中学习的人一样。

Jonathan Goldman，LinkedIn数据科学家。

2006年的6月份进入商务社交网站LinkedIn，当时LinkedIn只有不到800万用户。高德曼在之后的研究中创造出新的模型，利用数据预测注册用户的人际网络。具体来讲，他以用户在LinkedIn的个人资料，来找到和这些信息最匹配的三个人，并以推荐的形式显示在用户的使用页面上——这也就是我们熟悉的"你可能认识的人（People you may know）"。这个小小的功能让LinkedIn增加了数百万的新的页面点击量(数据挖掘的应用典型之一推荐系统）。

John Rauser, 亚马逊大数据科学家。

数据科学家是工程师和统计学家的结合体。从事这个职位要求极强的驾驭和管理海量数据的能力.同时也需要有像统计学家一样萃取、分析数据价值的本事，二者缺一不可。

Steven Hillion, EMC Greenplum数据分析副总裁。

数据科学家是具有极强分析能力和对统计和数学有很深研究的数据工程师。他们能从商业信息等其他复杂且海量的数据库中洞察新趋势。

Monica Rogati, LinkedIn资深数据科学家。

所有的科学家都是数据学家，因为他们整天都在和海量数据打交道。在我眼中，数据学家是一半黑客加一半分析师。他们通过数据建立看待事物的新维度。数据学家必须能够用一只眼睛发现新世界，用另一只眼睛质疑自己的发现。

Daniel Tunkelang，LinkedIn首席数据科学家。

我是bitly 首席科学家Hilary Mason的忠实崇拜者。关于这个新概念的定义我也想引用她的说法：数据科学家是能够利用各种信息获取方式、统计学原理和机器的学习能力对其掌握的数据进行收集、去噪、分析并解读的角色。

Michael Rappa，北卡罗莱纳州立大学教授。

尽管数据科学家这个名称最近才开始在硅谷出现，但这个新职业的产生却是基于人类上百年对数据分析的不断积累和衍生。和数据科学家最接近的职业应该是统计学家，只不过统计学家是一个成熟的定义且服务领域基本局限于政府和学界。数据科学家把统计学的精髓带到了更多的行业和领域。

林仕鼎，百度大数据首席架构师。

如果从广义的角度讲，从事数据处理、加工、分析等工作的数据科学家、数据架构师和数据工程师都可以笼统地称为数据科学家.而从狭义的角度讲，那些具有数据分析能力，精通各类算法，直接处理数据的人员才可以称为数据科学家。

最后引用Thomas H. Davenport（埃森哲战略变革研究院主任） 和 D.J. Patil（美国科学促进会科学与技术政策研究员，为美国国防部服务）的话来总结数据科学家需要具备的能力：

数据科学家倾向于用探索数据的方式来看待周围的世界。

（好奇心）

把大量散乱的数据变成结构化的可供分析的数据，还要找出丰富的数据源，整合其他可能不完整的数据源，并清理成结果数据集。

（问题分体整理能力）

新的竞争环境中，挑战不断地变化，新数据不断地流入，数据科学家需要帮助决策者穿梭于各种分析，从临时数据分析到持续的数据交互分析。

（快速学习能力）

数据科学家会遇到技术瓶颈，但他们能够找到新颖的解决方案。

（问题转化能力）

当他们有所发现，便交流他们的发现，建议新的业务方向。

（业务精通）

他们很有创造力的展示视觉化的信息，也让找到的模式清晰而有说服力。

（表现沟通能力）

他们会把蕴含在数据中的规律建议给Boss，从而影响产品，流程和决策。

（决策力）

三、数据科学家所需硬件技能

《数据之美 Beautiful Data》的作者Jeff Hammerbacher在书中提到，对于 Facebook 的数据科学家“我们发现传统的头衔如商业分析师、统计学家、工程师和研究科学家都不能确切地定义我们团队的角色。该角色的工作是变化多样的：

在任意给定的一天，团队的一个成员可以用 Python 实现一个多阶段的处理管道流、设计假设检验、用工具R在数据样本上执行回归测试、在 Hadoop 上为数据密集型产品或服务设计和实现算法，或者把我们分析的结果以清晰简洁的方式展示给企业的其他成员。为了掌握完成这多方面任务需要的技术，我们创造了

数据科学家

这个角色。”

(1) 计算机科学

一般来说，数据科学家大多要求具备编程、计算机科学相关的专业背景。简单来说，就是对处理大数据所必需的Hadoop、Mahout等大规模并行处理技术与机器学习相关的技能。

零基础学习 Hadoop 该如何下手？

想从事大数据、海量数据处理相关的工作，如何自学打基础？

(2) 数学、统计、数据挖掘等

除了数学、统计方面的素养之外，还需要具备使用SPSS、SAS等主流统计分析软件的技能。其中，面向统计分析的开源编程语言及其运行环境“R”最近备受瞩目。R的强项不仅在于其包含了丰富的统计分析库，而且具备将结果进行可视化的高品质图表生成功能，并可以通过简单的命令来运行。此外，它还具备称为CRAN（The Comprehensive R Archive Network）的包扩展机制，通过导入扩展包就可以使用标准状态下所不支持的函数和数据集。R语言虽然功能强大，但是学习曲线较为陡峭，个人建议从python入手，拥有丰富的statistical libraries，

NumPy

，

SciPy.org

，

Python Data Analysis Library

，

matplotlib: python plotting

。

如何系统地学习数据挖掘？

做数据分析不得不看的书有哪些？

怎么学习用R语言进行数据挖掘？

(3) 数据可视化（Visualization）

信息的质量很大程度上依赖于其表达方式。对数字罗列所组成的数据中所包含的意义进行分析，开发Web原型，使用外部API将图表、地图、Dashboard等其他服务统一起来，从而使分析结果可视化，这是对于数据科学家来说十分重要的技能之一。

有哪些值得推荐的数据可视化工具？

(4) 跨界为王

麦肯锡认为未来需要更多的“translators”，能够在IT技术，数据分析和商业决策之间架起一座桥梁的复合型人才是最被人需要的。”translators“可以驱动整个数据分析战略的设计和执行，同时连接的IT ，数据分析和业务部门的团队。如果缺少“translators“，即使拥有高端的数据分析策略和工具方法也是于事无补的。

The data strategists’combination of IT knowledge and experience making business decisions makes them well suited to define the data requirements for high-value business analytics. Data scientists combine deep analytics expertise with IT know-how to develop sophisticated models and algorithms. Analytic consultants combine practical business knowledge with analytics experience to zero in on high-impact opportunities for analytics.

天才的”translators“非常罕见。但是大家可以各敬其职（三个臭皮匠臭死诸葛亮），数据战略家可以使用IT知识和经验来制定商业决策，数据科学家可以结合对专业知识的深入理解使用IT技术开发复杂的模型和算法，分析顾问可以结合实际的业务知识与分析经验聚焦下一个行业爆点。

推荐关注：

https://www.facebook.com/data

四、数据科学家的培养

位于伊利诺伊州芝加哥郊外埃文斯顿市的美国名牌私立大学——西北大学（Northwestern University），就是其中之一。西北大学决定从2012年9月起在其工程学院下成立一个主攻大数据分析课程的分析学研究生院，并开始了招生工作。西北大学对于成立该研究生院是这样解释的：“虽然只要具备一些Hadoop和Cassandra的基本知识就很容易找到工作，但拥有深入知识的人才却是十分缺乏的。”

此外，该研究生院的课程计划以“传授和指导将业务引向成功的技能，培养能够领导项目团队的优秀分析师”为目标，授课内容在数学、统计学的基础上，融合了尖端计算机工程学和数据分析。课程预计将涵盖分析领域中主要的三种数据分析方法：预测分析、描述分析（商业智能和数据挖掘）和规范分析（优化和模拟），具体内容如下。

(1) 秋学期

* 数据挖掘相关的统计方法（多元Logistic回归分析、非线性回归分析、判别分析等）

* 定量方法（时间轴分析、概率模型、优化）

* 决策分析（多目的决策分析、决策树、影响图、敏感性分析）

* 树立竞争优势的分析（通过项目和成功案例学习基本的分析理念）

(2) 冬学期

* 数据库入门（数据模型、数据库设计）

* 预测分析（时间轴分析、主成分分析、非参数回归、统计流程控制）

* 数据管理（ETL（Extract、Transform、Load）、数据治理、管理责任、元数据）

* 优化与启发（整数计划法、非线性计划法、局部探索法、超启发（模拟退火、遗传算法））

(3) 春学期

* 大数据分析（非结构化数据概念的学习、MapReduce技术、大数据分析方法）

* 数据挖掘（聚类（k-means法、分割法）、关联性规则、因子分析、存活时间分析）

* 其他，以下任选两门（社交网络、文本分析、Web分析、财务分析、服务业中的分析、能源、健康医疗、供应链管理、综合营销沟通中的概率模型）

(4) 秋学期

* 风险分析与运营分析的计算机模拟

* 软件层面的分析学（组织层面的分析课题、IT与业务用户、变革管理、数据课题、结果的展现与传达方法）

（EMC的在线课程：

Data Science and Big Data Analytics Training

，收费T_T，大家可以了解下学习路径）

(5)分享一些免费的课程

以下课程免费，讲师都是领域的专家，需要提前报名，请注意开班的时间。

Coursera.org

：统计学。

Coursera.org

：机器学习。

Coursera.org

：数据分析的计算方法。

Coursera.org

：大数据。

Coursera.org

：数据科学导论。

Coursera.org

：数据分析。

名校课程，需要一定的英语基础和计算机基础：

Statistical Thinking and Data Analysis

：麻省理工学院的统计思维与数据分析课。概率抽样，回归，常见分布等。

Data Mining | Sloan School of Management

：麻省理工学院的数据挖掘课程，数据挖掘的知识以及机器学习算法。

Rice University Data Visualization

：莱斯大学的数据可视化，从统计学的角度分析信息可视化。

Harvard University Introduction to Computing, Modeling, and Visualization

: 哈佛大学，如何在数学计算与数据交互可视化之间架起桥梁。

UC Berkeley Visualization

：加州大学伯克利分校数据可视化。

Data Literacy Course -- IAP

：两个MIT的数据研究生，如何分析处理可视化数据。

Columbia University Applied Data Science

：哥伦比亚大学，数据分析方法。需要一定的数据基础。

SML: Systems

：加州大学伯克利分校，可扩展的机器学习方法。从硬件系统，并行化范式到MapReduce+Hadoop+BigTable，非常全面系统。

五、数据科学家的前景

（

EMC - Leading Cloud Computing, Big Data, and Trusted IT Solutions

，关于数据科学家的研究）

Like the physical universe, the digital universe is large – by 2020 containing nearly as many digital bits as there are stars in the universe. It is doubling in size every two years, and by 2020 the digital universe – the data we create and copy annually – will reach 44 zettabytes, or 44 trillion gigabytes.

EMC预测，按照目前的情况数字宇宙以每两年一番的速度倍增，在2020年将到达44ZB（1ZB=1.1805916207174113e+21B）。EMC做出了5点比较大胆的预测。

In 2013, while about 40% of the information in the digital universe required some type of data protection, less than 20% of the digital universe actually had these protections.

Data from embedded systems, the signals from which are a major component of the Internet of Things, will grow from 2% of the digital universe in 2013 to 10% in 2020.

In 2013, less than 20% of the data in the digital universe is “touched” by the cloud, either stored, perhaps temporarily, or processed in some way. By 2020, that percentage will double to 40%.

Most of the digital universe is transient – unsaved Netflix or Hulu movie streams, or Xbox One gamer interactions, temporary routing information in networks, sensor signals discarded when no alarms go off, etc. – and it is getting more so. This is a good thing, because the world’s amount of available storage capacity (i.e., unused bytes) across all media types is growing slower than the digital universe. In 2013, the available storage capacity could hold just 33% of the digital universe. By 2020, it will be able to store less than 15%.

In 2014, the digital universe will equal 1.7 megabytes a minute for every person on Earth.

Between 2013 and 2020 the division of the digital universe between mature and emerging markets (e.g., China) will switch – from 60% accounted for by mature markets to 60% of the data in the digital universe coming from emerging markets.

EMC预测在2017年左右新兴的市场将超越成熟市场，东亚国家是最具潜力的引爆点。（大家是不是有点小激动，前景一片光明）

六、结束语

推荐网站：

Data Science Central

（数据科学中心，大牛云集，资源丰富，讨论者热情，各种课程）

祝每一个DMer都挖掘到金矿和快乐：）

参考文献：

[1].

Data Scientists: The Definition of Sexy

[2].《大数据的冲击》. 城田真琴. 野村综合研究所创新开发部高级研究员、IT分析师，日本政府“智能云计算研究会”智囊团成员

[3].麦肯锡.

Big data: The next frontier for innovation, competition, and productivity

[4].EMC.

Executive Summary: Data Growth, Business Opportunities, and the IT Imperatives

[5].

EMC Greenplum's Steven Hillion on What Is a Data Scientist?

[6].

LinkedIn's Monica Rogati On "What Is A Data Scientist?"

[7].

IBM - What is a Data Scientist?

[8].

Data Science and Prediction

[9].

The key word in “Data Science” is not Data, it is Science

[10].

Data Science: How do I become a data scientist?

[11].

A Practical Intro to Data Science

[12].

解码数据科学家

赞同：1149

评论：39

Python 爬虫如何入门学习？

谢科

,

用python分布式地爬过豆瓣/Twitter Search

“入门”是良好的动机，但是可能作用缓慢。如果你手里或者脑子里有一个项目，那么实践起来你会被目标驱动，而不会像学习模块一样慢慢学习。

另外如果说知识体系里的每一个知识点是图里的点，依赖关系是边的话，那么这个图一定不是一个有向无环图。因为学习A的经验可以帮助你学习B。因此，你不需要学习怎么样“入门”，因为这样的“入门”点根本不存在！你需要学习的是怎么样做一个比较大的东西，在这个过程中，你会很快地学会需要学会的东西的。当然，你可以争论说需要先懂python，不然怎么学会python做爬虫呢？但是事实上，你完全可以在做这个爬虫的过程中学习python :D

看到前面很多答案都讲的“术”——用什么软件怎么爬，那我就讲讲“道”和“术”吧——爬虫怎么工作以及怎么在python实现。

先长话短说summarize一下：

你需要学习

基本的爬虫工作原理

基本的http抓取工具，scrapy

Bloom Filter:

Bloom Filters by Example

如果需要大规模网页抓取，你需要学习分布式爬虫的概念。其实没那么玄乎，你只要学会怎样维护一个所有集群机器能够有效分享的分布式队列就好。最简单的实现是python-rq:

https://github.com/nvie/rq

rq和Scrapy的结合：

darkrho/scrapy-redis · GitHub

后续处理，网页析取(

grangier/python-goose · GitHub

)，存储(Mongodb)

以下是短话长说：

说说当初写的一个集群爬下整个豆瓣的经验吧。

1）首先你要明白爬虫怎样工作。

想象你是一只蜘蛛，现在你被放到了互联“网”上。那么，你需要把所有的网页都看一遍。怎么办呢？没问题呀，你就随便从某个地方开始，比如说人民日报的首页，这个叫initial pages，用$表示吧。

在人民日报的首页，你看到那个页面引向的各种链接。于是你很开心地从爬到了“国内新闻”那个页面。太好了，这样你就已经爬完了俩页面（首页和国内新闻）！暂且不用管爬下来的页面怎么处理的，你就想象你把这个页面完完整整抄成了个html放到了你身上。

突然你发现， 在国内新闻这个页面上，有一个链接链回“首页”。作为一只聪明的蜘蛛，你肯定知道你不用爬回去的吧，因为你已经看过了啊。所以，你需要用你的脑子，存下你已经看过的页面地址。这样，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。

好的，理论上如果所有的页面可以从initial page达到的话，那么可以证明你一定可以爬完所有的网页。

那么在python里怎么实现呢？

很简单

import

Queueinitial_page

=

"http://www.renminribao.com"url_queue

=

Queue.Queue()seen

=

set()seen.insert(initial_page)url_queue.put(initial_page)while(True):

#一直进行直到海枯石烂

if

url_queue.size()>0:

current_url

=

url_queue.get()

#拿出队例中第一个的url

store(current_url)

#把这个url代表的网页存储好

for

next_url

in

extract_urls(current_url):

#提取把这个url里链向的url

if

next_url

not

in

seen:

seen.put(next_url)

url_queue.put(next_url)

else:

break

写得已经很伪代码了。

所有的爬虫的backbone都在这里，下面分析一下为什么爬虫事实上是个非常复杂的东西——搜索引擎公司通常有一整个团队来维护和开发。

2）效率

如果你直接加工一下上面的代码直接运行的话，你需要一整年才能爬下整个豆瓣的内容。更别说Google这样的搜索引擎需要爬下全网的内容了。

问题出在哪呢？需要爬的网页实在太多太多了，而上面的代码太慢太慢了。设想全网有N个网站，那么分析一下判重的复杂度就是N*log(N)，因为所有网页要遍历一次，而每次判重用set的话需要log(N)的复杂度。OK，OK，我知道python的set实现是hash——不过这样还是太慢了，至少内存使用效率不高。

通常的判重做法是怎样呢？

Bloom Filter

. 简单讲它仍然是一种hash的方法，但是它的特点是，它可以使用固定的内存（不随url的数量而增长）以O(1)的效率判定url是否已经在set中。可惜天下没有白吃的午餐，它的唯一问题在于，如果这个url不在set中，BF可以100%确定这个url没有看过。但是如果这个url在set中，它会告诉你：这个url应该已经出现过，不过我有2%的不确定性。注意这里的不确定性在你分配的内存足够大的时候，可以变得很小很少。一个简单的教程:

Bloom Filters by Example

注意到这个特点，url如果被看过，那么可能以小概率重复看一看（没关系，多看看不会累死）。但是如果没被看过，一定会被看一下（这个很重要，不然我们就要漏掉一些网页了！）。 [IMPORTANT: 此段有问题，请暂时略过]

好，现在已经接近处理判重最快的方法了。另外一个瓶颈——你只有一台机器。不管你的带宽有多大，只要你的机器下载网页的速度是瓶颈的话，那么你只有加快这个速度。用一台机子不够的话——用很多台吧！当然，我们假设每台机子都已经进了最大的效率——使用多线程（python的话，多进程吧）。

3）集群化抓取

爬取豆瓣的时候，我总共用了100多台机器昼夜不停地运行了一个月。想象如果只用一台机子你就得运行100个月了...

那么，假设你现在有100台机器可以用，怎么用python实现一个分布式的爬取算法呢？

我们把这100台中的99台运算能力较小的机器叫作slave，另外一台较大的机器叫作master，那么回顾上面代码中的url_queue，如果我们能把这个queue放到这台master机器上，所有的slave都可以通过网络跟master联通，每当一个slave完成下载一个网页，就向master请求一个新的网页来抓取。而每次slave新抓到一个网页，就把这个网页上所有的链接送到master的queue里去。同样，bloom filter也放到master上，但是现在master只发送确定没有被访问过的url给slave。Bloom Filter放到master的内存里，而被访问过的url放到运行在master上的Redis里，这样保证所有操作都是O(1)。（至少平摊是O(1)，Redis的访问效率见:

LINSERT – Redis

)

考虑如何用python实现：

在各台slave上装好scrapy，那么各台机子就变成了一台有抓取能力的slave，在master上装好Redis和rq用作分布式队列。

代码于是写成

#slave.pycurrent_url = request_from_master()to_send = []for next_url in extract_urls(current_url):    to_send.append(next_url)store(current_url).send_to_master(to_send)#master.pydistributed_queue = DistributedQueue()bf = BloomFilter()initial_pages = "www.renmingribao.com"while(True):    if request == 'GET':        if distributed_queue.size()>0:            send(distributed_queue.get())        else:            break    elif request == 'POST':        bf.put(request.url)

好的，其实你能想到，有人已经给你写好了你需要的：

darkrho/scrapy-redis · GitHub

4）展望及后处理

虽然上面用很多“简单”，但是真正要实现一个商业规模可用的爬虫并不是一件容易的事。上面的代码用来爬一个整体的网站几乎没有太大的问题。

但是如果附加上你需要这些后续处理，比如

有效地存储（数据库应该怎样安排）

有效地判重（这里指网页判重，咱可不想把人民日报和抄袭它的大民日报都爬一遍）

有效地信息抽取（比如怎么样抽取出网页上所有的地址抽取出来，“朝阳区奋进路中华道”），搜索引擎通常不需要存储所有的信息，比如图片我存来干嘛...

及时更新（预测这个网页多久会更新一次）

如你所想，这里每一个点都可以供很多研究者十数年的研究。虽然如此，

“路漫漫其修远兮,吾将上下而求索”。

所以，不要问怎么入门，直接上路就好了：）

赞同：1127

评论：69

程序员新人怎样在复杂代码中找 bug？

姚冬

,

招聘音视频相关算法工程师

我曾经做了两年大型软件的维护工作，那个项目有10多年了，大约3000万行以上的代码，参与过开发的有数千人，代码checkout出来有大约5个GB，而且bug特别多，open的有上千，即使最高优先级的showstopper也有上百。

分享下我的debug的经验

1. 优先解决那些可重现的，可重现的bug特别好找，反复调试测试就好了，先把好解决的干掉，这样最节约时间。

2. 对于某些bug没有头绪或者现象古怪不知道从哪里下手，找有经验的同事问一下思路，因为在那种开发多年的大型系统里，经常会反复出现同样原因的bug，原因都类似，改了一处，过一阵子另外一处又冒出来，而且无法根治。

比如：我那个系统里有个特别危险的API，接口参数比较难用，一旦有人用错了某些情况下就会出诡异的现象，解决很简单，找到调用这个API的地方把调用方式写对就好了。为什么不根治呢？因为要保持兼容性不能改接口了。Windows系统里就好多这种烂API。

问下老员工吧，说不定他们都遇到过好多次了。

3. 放大现象，有些bug现象不太明显，那么就想办法增大它的破坏性，把现象放大。这只是个思路，具体怎么放大只能根据具体的代码来定。

比如：美剧《豪斯医生》里有一集，怀疑病人心肺有问题，就让病人去跑步机上跑步，加重心肺负担，从而放大症状。

4. 二分法定位，把程序逻辑一点点注释掉，看看还会不会出问题，类似二分查找的方法，逐步缩小问题范围。

5. 模拟现场，有时候我会问自己，如果我要实现bug描述的现象我要怎么写代码才行？

比如：我遇到一个死锁问题，但是检查代码发现所有的锁都是配对的，没有忘记解锁的地方，而且锁很简单就是一个普通的临界段，保护几行赋值语句而已。这样的代码怎么写才能让他死锁呢？

我想如果让我故意制造这样一个现象，只有在上锁的时候强制杀掉线程了。

既然这样就可以去看看有谁强杀线程了没有。

6. 制作工具，针对某些bug编写一些调试辅助工具。

比如，我那个系统没有完善的崩溃报告，虽然也有dump，但是分析出来的callstack经常不准。于是我为解决崩溃问题编写了个工具，会自动扫描代码，在每个函数入口和出口插入log，以此来定位崩溃点。

7. 掩盖问题，虽然这样做有点不厚道，但是有时不得不这么做。有些bug找不到真正的root cause，但是又要在规定时间内解决，那么我们就可以治疗症状而不去找病因。比如用try catch掩盖一些奇怪的崩溃。不到万不得已不要这么干，未来可能会付出更大代价。

我在做这份工作的时候也在追美剧《豪斯医生》，豪斯大叔解决病症的思路和debug差不多，对我很有启发。

赞同：969

评论：70

怎样成为全栈工程师（Full Stack Developer）？

Cat Chen

,

上知乎，求欢乐

既然原文是说，Facebook 工程师说 Facebook 只招 full stack engineer，那我就来说说 Facebook engineer 都是怎样的人啦。

我觉得任何一方面的具体经验都不重要，重要的是思维方式和学习能力。首先说思维方式，那就是不为自己设限，不会想着自己是前端工程师，所以后端的东西我就一点也不碰。Facebook 的工程师，级别越高就需要保持越大的影响力。如何创造更大的影响力，就是寻找当前杠杆效应最明显的问题来解决。有些问题你解决了的话，投入进去的时间每小时能换回来一千美元.有些问题你解决了的话，投入进去的时间每小时能换回来一百万美元。然而哪些问题更值得解决，这是动态的，往往还存在衰减效应。如果现在性能瓶颈在后端，你做了一个季度两个季度优化后，瓶颈就已经不在后端了，你再优化下去衰减效应就会越来越明显。等瓶颈变成前端了，你是不是就说因为你不懂，所以不愿意碰？那就相当于寄望于公司有个前端很懂性能优化的人来解决，但如果公司没有这样的人那就没有人来解决了。

Facebook 的众多海报当中，有一张写的是「任何一个 Facebook 的问题，都不是别人的问题」。有问题，你就需要去评估是否值得解决。如果值得解决，你就应该着手去解决，而不是假设公司内会有另外一个人比你更合适解决这个问题。这时候很可能你就需要去做你从来没有做过的事情，需要学习你原本可能完全不懂的技术。如果你是个专门做数学模型的博士，加入 Facebook 原本是打算做搜索结果优化的，结果发现这不是最急需解决的问题，JavaScript 性能才是最需要解决的问题，你怎么办？如果你以为 Facebook 需要的是你做数学模型的经验，那你就错了。Facebook 需要的是你完成博士学位的学习能力。你从来没做过 JavaScript 并且觉得 JavaScript 很恶心？正确的做法是立即在网上买几本 JavaScript 入门的书连夜看完，然后着手分析性能瓶颈并且解决。在你完成手动优化后，你还可以思考一下能否把这做成自动化，例如说在代码提交时分析 JavaScript 语法树并且指出可能成为性能瓶颈的地方，又或者说从用户浏览器那里收集性能数据扔到 Hive 然后再从中分析产生瓶颈的特征。这些都可能涉及到一些你没有做过也没有学过的东西，但问题摆在那里你就需要去解决，而无论这要求你去钻研什么。这就是我所说的学习能力。

这是高级工程师和初级工程师的主要差距。尽管在高级到初级这一维度上，美国工程师和中国工程师是有重叠的，但美国的教育体系和行业传统使得美国应届生比一般中国工程师更偏向于高级那一端。美国学生的优势在于，他们的教育体系让他们习惯面对开放性问题。一家公司万千问题当中，此时此刻哪一个最值得解决？这不是中国工程师擅长的问题，因为实在是太开放了。中国教育让人擅长在给定条件下解决问题，太开放反而不知道从何入手。此外因为绝大多数文献都是英文的，所以要钻研什么对于能读懂英文的人来说都可以非常成体系的学习，这对于很多拒绝阅读英文的中国工程师来说很不利。拒绝阅读英文意味着永远只能接受别人的二手资料，对于很多概念的理解只能停留在技师的层面，而无法上升到工程师或者科学家的层面。

赞同：923

评论：48

显著提升程序员身心健康和工作效率的装备有哪些？

王一

,

主攻鉴证语言学的码农

好吧，作为一枚萌妹子，不敢自称程序猿，但也是常年电脑前累弯了腰……

我把压箱底的好物拿出来了……

把名字告诉大家，叫Varier，他们家的椅子人体工学做得特别好，谁坐谁知道……

主页在这里：

Varier

貌似香港是有专卖店的，估计也可以找个代购。

看上去貌似不稳，上去坐一下就知道了！椅子会自然前倾一个角度，保证你的脊柱是成一条直线，脖子自然伸直，你想弯都弯不了，而且肌肉完全不受力不绷紧。

对比大概是这样：

还可以往后仰：

还有个终极版，号称零重力，比较适合休息小睡放松时候用的，但是上面只要加一个机械臂来固定电脑，一样可以躺着写代码的……就是比较贵，2000多刀的样子。

------------------------------------------6月30日逗逼的更新------------------------------------

承蒙大家厚爱！

来小更新一下。之所以把更新放在原答案下面而不是上面，是因为这个更新纯属娱乐成分居多，虽然东西是绝逼好物，但是估计性价比不高。大家随便看看就好，没准不远的将来此物性价比上升，咱都可以随便来两个，一个放家一个放办公室……

出场的程序员装逼神器为……

Stir Kinetic Desk,

Meet the Stir Kinetic Desk

简单地说，就是此桌可以自动上升下降，桌面有显示屏记录数据，可以提醒你今天坐了多少时间站了多少时间，坐久了应该要站一下。还可以记录你的习惯，到时候桌子自动提醒你应该站一会儿了。大家感兴趣可以去看一下介绍视频。

目前只在美国发售。前苹果员工的公司做的。新产品，比较贵，我打算等降价，或者同类型竞争产品出来。如果价格可以接受，就入一个。

赞同：651

评论：118

很多网站提供用微博和 QQ 账号登录，好处是什么呢？

林灿斌

,

八年老码农

谢邀！8月下旬刚好搞过OAuth。

首先反对目前赞同数超过1的除了我以外的所有回答。

回答下题主本身的问题：很多网站提供用微博和QQ账号登录，好处是什么呢？

好处是当你登陆了QQ客户端或者微博时，用户可以不输入账号密码

直接点击

（无需输入任何数据）使用绑定的QQ号或微博账号

登陆

。这个需求是很大的，我网站设立初期就有很多人要求我添加这个功能。

这个我做过调查，确实很多用户需要，因为登录了QQ客户端，在那些网站就不需要输入密码登陆了。没调查就没有发言权。

————————————以下为战斗部分——————————————

1、

@Benjamin

提到的 “诱使用户误以为不用注册账号就能登录他们的网站了，有利于吸引用户。” 这个其实

QQ互联官方的要求就是：“点击登陆后，要直接就是登陆，不能要求设置账号密码什么的”，不然无法通过审核

，我前期就是这样无法通过审核，后期在代码里动了点手脚才过的，审核通过后又改了回去。

设置昵称这个前期小小麻烦，以后的还是会很方便的，毕竟以后就不用再输入了。

2、

@DecKen

的说法，“所谓的使用微博和QQ账号登陆，无非是网站想获取你更多的信息（QQ号，微博）”，也是错误的。OAuth协议返回给接通微博登陆或者QQ登陆的网站的登陆数据，只有一串可以叫做openid的字符串，并没有QQ账号，当然你可以拿着openid等数据继续通过腾讯的OpenAPI继续获取更多资料（JSON格式），例如昵称什么的，但是还是没有QQ号。例如get_user_info的API，只能取得如下数据。

{

"ret":0,

"msg":"",

"nickname":"Peter",

"figureurl":"http://qzapp.qlogo.cn/qzapp/111111/942FEA70050EEAFBD4DCE2C1FC775E56/30",

"figureurl_1":"http://qzapp.qlogo.cn/qzapp/111111/942FEA70050EEAFBD4DCE2C1FC775E56/50",

"figureurl_2":"http://qzapp.qlogo.cn/qzapp/111111/942FEA70050EEAFBD4DCE2C1FC775E56/100",

"figureurl_qq_1":"http://q.qlogo.cn/qqapp/100312990/DE1931D5330620DBD07FB4A5422917B6/40",

"figureurl_qq_2":"http://q.qlogo.cn/qqapp/100312990/DE1931D5330620DBD07FB4A5422917B6/100",

"gender":"男",

"is_yellow_vip":"1",

"vip":"1",

"yellow_vip_level":"7",

"level":"7",

"is_yellow_year_vip":"1"

}

基本只有昵称、各种尺寸的头像的URL，性别，黄钻相关的信息。

另外其实我很奇怪知乎很多完全没有网站开发经验的人也来回答这种问题。

以下为我QQ登陆数据表所储存数据，可以看到我只保存了openid，并没有QQ号，不是不想保存，是没有API可以获取到这种资料。

openid每个用户各不相同，据我推测应该是用QQ号以某种算法加密出来的，可能有一一对应的关系。看起来应该是用MD5加密出来的密文，我试过加密自己的QQ号，结果与上面不符合，加密两次，也不对，如果是MD5+salt之类的，那么可以认为是无法通过openid逆向工程得出QQ号的。

当然，新浪微博的API权限就高很多了，甚至可以用那些API，做出Fuubo这样的东西，所以获取微博的地址是可以办到的。当然，这也是合理的，因为微博的定位就是微型博客，博客不同于QQ、手机号码这样的私人联系方式，博客在不作隐私设置的前提下对网络上的任何人都是公开的，因此获得新浪微博的地址并无任何不妥。

像我的新浪微博地址：

http://weibo.com/lincanbin

我就可以非常大方地放出来让你们关注。

3、所以

@段炼

的说法，也是错误的，OAuth协议只返回openid，并不返回登陆密码。

4、

@安雅

的“直接引入原qq好友关系”这个功能是不存在的。

5、

@VrWorking

的关于移动终端登陆的说法（原文：“如果在手机或平板客户端 App，就比较难了。因为 App 的特点你是看不到地址栏的，因此无法确认这个登录页面是不是腾讯的。只能看这个 App 是否是官方的，和是否具备足够的知名度。满足这两个条件下的 App 开发商不会、也没必要去偷取你的账户信息（也不绝对，比如 CSDN 脑残程序员偷偷的保存用户密码明文到数据库，结果城门失火殃及池鱼）。”），其实腾讯是有另一个API，可以调用QQ客户端登陆的，并非只有Webview一个方法。不过目前这个只支持安卓和IOS，WP等小众系统是不支持的，如下图：

使用了这个API的，大家比较熟悉的就有“天天爱消除”、“唱吧”等等，不需要使用WebView跳转到一个网页手动输入账号密码登陆，也是非常方便的。不过SSO登陆这个API会启动QQ客户端，响应在一些手机上相对比WebView较迟缓。

6、

@痴梦

说的“婊子立牌坊”，也是错误的说法，首先腾讯的QQ互联要求（即“登陆后不需添加任何新的即可直接登陆”）只适用于留言板等应用，而论坛之类的应用，并不适合。

像各位想保护隐私嘛，所以腾讯返回给与QQ互联互通网站的信息也是有限的，有用的只有一个opedid和name（昵称）。可是论坛为了区分各个用户，

必须有identifie

，对外展示，所以至少需要再设定一个昵称。可是一个拥有多套登陆系统（必须有多套，最起码自己得有一套，不然就丧失独立性了）的网站，把Openid作为mainkey显然是不合适的，name的话更不用说，是绝对不能作为identifie的——因为有含有非法字符或者过长的可能性，也可能重复，

有的网站也有提供UID登陆或者邮箱地址登陆的功能

，如果直接把QQ昵称作为username入库，就可能导致该用户通过常规途径登陆失败。

简言：把腾讯返回的name作为username入库前需要做合法性检测，所以用户名是必须在登陆后再次填写的。除非你打算全站只用QQ这个登陆系统，而不采用自己独立的账号系统。

（合法性检测：长度，不能全为数字，不包含非法字符，数据库user表同字段中不存在相同数据。）

当然，

有些网站像知乎，是允许使用已存在的name的并且可以任意修改的

，像我叫林灿斌，你也可以在知乎注册个号叫林灿斌，你QQ昵称是林灿斌，用QQ登陆后知乎自动帮你创建一个name是林灿斌的号，

这样的网站逻辑就可以不输入新昵称直接登陆

。而大多数网站，像大部分论坛、微博……name都必须是唯一的，这样就不可能实现直接登陆，有些是历史遗留问题，有些是本意如此。

最后按照知乎答非所问的风气，最后应该会有人出来普及OAuth协议然后获得高票赞同吧，建议那些并没有相关经验的回答者等那种普及知识的回答出现并且看完再作答。

————————————————————————

最后，其实QQ的审核规定还是挺严格的，不过QQ旗下的Discuz是不需要遵照这个规定的。

因此很多使用DIscuz的论坛，都这样，造成了混乱，与腾讯本意相违，这里抄送腾讯反省一下。

————————————————————————

另外还是有好网站的，像我的网站，用QQ或者微博登陆，只需要设置一个在我站显示的昵称（原因见第6条），并不需要设置密码（当然也在设置里提供了设置密码的选项）。那些让那么多人骂娘的网站，多数是采用了一家不遵守腾讯QQ互联规定的公司旗下的Discuz的程序。

赞同：484

评论：63

写一个操作系统内核有多难？大概的内容、步骤是什么？

林文

,

Student Of CompSci

“一个好一点儿的计算机硕士毕业的学生。写一个操作系统的内核绝对是应该办到而且肯定可以办到的事儿。” －－－－－－这句话我们可以理解为”

一个好的计算机硕士掌握的理论知识足够他搭建起一个简单的操作系统框架

“。

我上操作系统课（大二）的第一天就问我的老师，学完了这门课可以自己实现一个操作系统了吗？老师说：”你可以

基本掌握操作系统中要处理的主要问题，但是即使实现最简单的五脏俱全的操作系统还需要掌握很多很多东西，而且前提是你已经有很不错的代码能力。

“

回到题目上来，我们要实现一个简单的操作系统，最先需要解决的是哪些问题？这个问题我相信翻开任何一本操作系统书都可以得到答案，一般都是操作系统书的前五，六章内容（第一章基本是操作系统概念及发展历史）。

包括：

进程管理

存储管理

文件系统

输入/输出

这些大部分是讨论理论类的书，比如我们上课用的书是西电汤子瀛老师的《计算机操作系统》，后来自己为了深入学习买了Andrew S. Tanenbaum的《Modern Operating Systems》。

如果想写个操作系统，除了理论知识外，动手之前最好先看看操作系统源代码，Linux的代码都是开源的，可以先学习学习。不过对于

我们这种初学者千万不要看最新的Linux内核代码

，因为那是很多人的杰作，可能一辈子都看不完。最好先看看国内同济大学赵炯基于0.11的《Linux完全注释》，即使只看懂30％也至会让自己懂很多之前不知道的东西。

理论类的书很少有提到Bootload问题的，就是加电之后从哪里开始执行的部分。仅仅是这个步骤也需要花不少时间去了解CPU知识，汇编语言知识等，相当不容易。不话说回来，这部分如果能处理好之后会发现

组成原理，汇编语言，微机原理的知识被自己运用到了，成就感巨大

。这部分内容，可以参看MIT的课程

6.828 Operating System Engineering

的课程，Google一下就能搜到不少大牛关于这门课的博客。如果英语不太好我记得

华中科技大学有一个叫32位操作系统实践的课

，资料都放到网上了，看起来很不错。

过了这一关，用《深入理解计算机系统》加上《现代操作系统》看一下虚拟存储器的内容，这两本书这部分说得都很棒。虚拟存储器的概念贯穿所有，如果能弄懂，对很多方面都有很大的帮助，不仅仅是操作系统这块。有了

虚拟存储器概念之后对于链接，加载等知识理解就会深刻许多。

不过，这部分内容也需要对硬件部分有所了解，又是一坑。

之后回到进程上来之后，终于可以把工作重心从硬件部分转移过来了。但是我们又将面对进程创建，进程调度，进程通信三大问题，既然是简单实现，就先不考虑线程的事。算法书中会给很多，不过这些算法都是有一定的局限性，比如调度算法，对应的调度算法优劣差异很大，至于如何抉择就看个人需求。不过话说回来，操作系统里的”算法“和ACM里的算法在难度上差很多，还是比较容易实现的。

内容太多了，就不完全展开了，后面就看自己“耐力”了，写操作系统是需要坚持很长实践＋大量知识积累的。有些问题还涉及到哲学的观点，这里推荐上海交大邹恒明教授的《操作系统之哲学原理》。除了理论方面的书，现在市面上也有直接教如何实现一个操作系统的，比如

《Orange'S:一个操作系统的实现》和《30天自制操作系统》

(仅有的几本“XX天XX”而不是烂书的书)，起步阶段跟着这些书来还是很不错的。

总之，实现最最基本的功能也许可以做到。实现功能强大，鲁棒性强的操作系统极难。

不过在此过程中学到了很多很多东西。无论最后能否实现属于自己的操作系统，在此过程中收获的知识是一笔宝贵的财富。

赞同：427

评论：32

如何正确地使用设计模式？

陈硕

,

Linux C++程序员，muduo 网络库作者

除非你还在写 Java，否则设计模式真没多大用处。

---- 补充几句 ----

首先明确一点，这里说的“设计模式”，是“面向对象设计模式”的简称，以 GoF 书中列出的 23 个模式为代表。

不要把什么都归为模式，比如 “if-then-else 模式”、“for each 模式”就不是（面向对象设计）模式。Like, the inverse, reverse, double-back-flip pattern—whatever. Oh, you mean a loop? OK. --- Jamie Zawinski

类似的，thread pool、thread-per-connection、process-per-connection、thread local storage、scoped locking、readers-writer lock 等等也不是面向对象设计模式。

赞同

@winter

说的 “建议不要泛泛地讨论和学习‘设计模式’，而是具体到每一个模式。”

如果你用的语言能把类型像变量一样赋值并传来传去，很多创建型模式就没用了。

如果你用的语言能把函数像变量一样赋值并传来传去，很多行为模式就没用了。

如果你用的语言 style 反对叠床架屋的 class hierarchy，很多结构模式就没用了。

几个简单具体的代码示例：

1. C# 内置了 delegate/event，Observer 模式就没用了。

2. 如果你的语言的 typeof 操作符能得到 runtime type，那么 Prototype 模式就没用了。比如

class

Base(object):

passclass

Derived(Base):

passdef

clone(x):

return

type(x)()if

__name__

==

'__main__':

d

=

Derived()

print

type(d)

# <class '__main__.Derived'>

c

=

clone(d)

print

type(c)

# <class '__main__.Derived'>

b

=

Base()

print

type(b)

# <class '__main__.Base'>

a

=

clone(b)

print

type(a)

# <class '__main__.Base'>

3. 如果类型能像变量一样赋值和传递，Factory method 模式就没用了。比如

class

Base(object):

passclass

Derived(Base):

passdef

getCreator(ty):

def

create():

obj

=

ty()

# initialize obj

return

obj

return

createif

__name__

==

'__main__':

d

=

getCreator(Derived)

b

=

getCreator(Base)

print

type(d())

# <class '__main__.Derived'>

print

type(b())

# <class '__main__.Base'># 这个例子做作了一些，可以看第二个链接里的例子。

更多的例子见

http://norvig.com/design-patterns/design-patterns.pdf

http://cdn.oreillystatic.com/en/assets/1/event/12/_The%20Lack%20of_%20Design%20Patterns%20in%20Python%20Presentation.pdf

4. 如果函数能像变量一样赋值和传递，Command、Strategy 等模式就没用了。

5. EventHandler/ConcreteEventHandler 这种 callback API 风格在现代语言里基本绝迹，C++ 有 std::function、C# 有 delegate、连 Java 8 都有了 Lambda，更别说动态语言了。

6. 有的语言有全局变量，Singleton 模式就没用了。Singleton 是最简单也最被滥用的模式。

7. 有的语言有 multiple dispatch，Vistor 模式就没用了。其实 Vistor 模式一直就没啥用。

赞同：280

评论：55

vczh

,

专业造轮子 www.gaclib.net

设计模式是为了封装变化，让各个模块可以独立变化。精准地使用设计模式的前提是你能够精准的预测需求变更的走向。我们都知道大部分人是做不到的，所以大部分人就算精通设计模式也多少会做错点什么东西。所以这其实不怪设计模式<del>，怪产品狗</del>。

所以说如何避免过度设计，这就要求你深入的理解你的程序所在的领域的知识，了解用户使用你的软件是为了解决什么问题，这样你预测用户的需求才会比以前更加准确，从而避免了你使用设计模式来封装一些根本不会发生的变化，也避免了你忽视了未来会发生的变化从而发现你使用的模式根本不能适应需求的新走向。

所以，在你满足了【知道所有设计模式为什么要被发明出来】的前提之后，剩下的其实都跟编程没关系，而跟你的领域知识和领域经验有关系。

赞同：121

评论：7

庄表伟

,

爱阅读、爱思考、爱生活、爱老婆、爱点宝、爱IT、爱美食、爱旅游、爱聊天、我是庄表伟，我爱这一切。http://www.zhuangbiaowei.com/

谢邀，不过首先要反对的是问题本身。

优雅？啥意思？优雅的使用？啥意思？优雅的使用设计模式？啥意思？

我决定以自己的思路来谈论“设计问题”。

软件肯定有架构

软件的架构一定是通过人脑的智力活动，主动的设计出来的

我们如果不断的学习和总结，在别人的经验、架构、代码中，的确会发现模式

设计(架构)的目的，首先是为了满足已知的需求，而非应对未知的变化

大多数自作聪明的预测，都会最终导致过度设计

所以，使用设计模式，首先需要确认场景：就目前能够明确的需求，设计(架构)需要面对的是怎样一个场景。然后，针对这种场景，选择合适的设计模式。

如果，我们与某个架构师发生了如下对话：

问：请问，这里为何要......这样设计？

答：因为，如果出现了......我的这个设计就能够不必修改，直接支持

问：那么，你假设的这种情况，是否会出现呢？

答：......如果它出现了，我们就节约了大量的修改，而且这是一个经典的XX模式

就此我们可以判定，这个架构师想多了。

所以，我不来谈什么优雅，我认为恰好满足需求的中庸才是正确的做法。我以儒家的子曰作为结尾：「過猶不及。」

外一篇：

架构的力量 - 思考IT - 知乎专栏

赞同：14

评论：2

猛禽

,

落伍程序员

这个话题我在五年前说过（

玄妙的设计模式

），使用模式的正确的方法是：

学习，然后全部忘记

。

学习的原因在于这是有价值的经验，而忘记的原因在于防止滥用。

设计模式的概念来自于建筑大师C.Alexander的名著《建筑的永恒之道》，本身是一种哲学思想。在这种哲学中，建筑有两种：一种是生机勃勃的，一种是死气沉沉的。二者的区别在于有生气的建筑具备了一种特质，它无处不在却又无法命名。这种无名特质无法被创造，而只能是自然地生长出来。

而模式是什么？模式是从有生气的建筑中总结出来的一些共性的东西。但堆砌模式并不能带来无名特质。因为无名特质像花一样，你不能用摄子堆砌细胞的方法造出一朵花来，它不能被构建，而只能是从种子自然生长起来。

同样堆砌模式不能带来具有无名特质的代码，而是只能造就僵死的代码。那么要如何“使用”模式？关键就在于此：

模式不是被使用的！

回到模式概念的本源。

模式并不是我们要追求的目标，我们的目标是写出有生气的代码，具备的无名特质的代码将会是它自己的主人，它将随着自然生长而越变越好。而要达到这个目标，模式只是一个手段而已。

只要想通这一点就好办。以有生气的代码为目标去写，你会发现有一些模式会自然而地出现在你的代码中。这才是模式该用到的时候。而且随着你经验的增加，你会发现有一些新的模式自然产生，它与你用的语言，与你的所开发的应用，甚至与你的性格、信仰都有关系。与GoF或其他什么大牛没有关系。

这时就你超越了大牛，拥有了你自己的模式语言，写出了具备无名特质的代码，踏上了属于你自己的编程永恒之道……

赞同：12

评论：1

怎么样才算是精通 Python？

Rio

,

「IT 公论」主播

我认为「精通」要满足如下条件：

熟知主流硬件体系（x86, x64）

熟知 CPython 的具体实现，如若可能至少通读源码三遍以上

熟知每条 Python bytecode 如何被解释执行

熟知每条 Python 语句如何 compile 成 bytecode

熟知 Python 主要数据结构所采用的优化手段

熟知 JIT 以及哪些场合下 PyPy 会比 CPython 有较大性能提高、以及有什么代价

所以我一直只敢称自己为 「中级 Pythonista」。对于那些仅仅知道怎么用 Python 就敢自称「精通」的人：专家不是那么好当的，没有金刚钻别揽瓷器活。不懂那么多底层细节就不要随便说自己「精通」，说自己「擅长」不会被人看不起。

@米嘉 引用的 StackOverflow 上列的那几项条件是作为将 Python 用于主要工作语言所需要的

基本条件

，敢于因此而称自己「精通 Python」要让不少人笑掉大牙。况且那几项还有几个严重问题：

第3点：如若可能，尽量避免 map/reduce/fitler，而用 list/generator/set comprehension，代码要清晰得多，GvR 如此说。xrange 和 range 的区别在 Python 3 中马上就要滚蛋了，所以如非必要，

不要大量使用 xrange。

第5点：敢于在 CPython 中大量使用递归是对 CPython 实现的公然侮辱。Python 的多个稳定实现都没有 TCO，递归会让性能迅速下降。记住一点：Python 中函数调用

非常

昂贵，可读性、可维护性影响不大的情况下，能展开函数调用的时候尽量展开、递归能转化成循环的尽量转化。递归也不是人类自然的思考方式。

第7点：看书是对的，但不要把 Python 当作一门经典函数式语言对待，因为它不是。你当它是，它会很痛苦（“为毛要这样滥用我！？”），你也会很痛苦（“为毛你不这样实现 blah blah！？”）。SICP 是本好书，但不要因此而教条。要清楚的知道什么时候用函数式，什么时候用面向对象，什么时候用面向过程，什么时候用面向任务，什么时候用面向结果。

在一棵树上吊死是大多数非理性死忠的表现。

赞同：382

评论：81

为什么那么多人会喜欢编程，怎么进入那个状态的呢？

袁浩瀚

,

Quant, Geek, Actuary, Photographer

作为一个写程序很长时间但是不以程序员为职业的人，我爱coding，我说说我的感受：

1. 世界上有很多系统是完全由人设计的，比如金融、比如计算机。但是数学和计算机是两种最常见的确定式系统。举个例子，金融系统基本由人类设计，但是在市场上，你的对口是人，比如股市是人与人之间的博弈，人是不确定的，因此这个系统也是不确定的，小概率（黑天鹅）事件比比皆是，作为一个赌性不强的人，我对于这种非确定性系统，是爱恨交织的。但是数学和计算机的根本都是1+1=2，或者1+1=10（二进制），一旦你掌握了原理，你是可以完全确定的去完成很多事情的。但是数学的创造远难于编程，因此我对于在一个确定性系统下去创造的感觉，只能说很踏实很爽。相信很多朋友也有这种感受。

2. 编程让你的思维会条理化，细致化：编程说简单了，就是告诉计算机按照一定的步骤去高速完成任务。人的特点是可以直觉思考（intuitive thinking），但是计算速度有限.计算机的特点是不能直觉思考但非常听安排，但是计算速度巨快。所以编程是一个你教计算机如何去做一件事情的过程，比如 如何把大象关进冰箱。当你熟练后，你会发现你的思考问题的条理好了很多，做事一二三四步安排得很清楚，步骤先后顺序（拓扑关系）也能处理得很好。同时，编程要考虑很多极端情况，比如内存溢出。编程越来越多，你会发现自己越来越谨慎，特别是长期做网站等交互性比较强的程序后，你会反复思考如何面对 变态用户，到后来你做事就会越来越细致。这个思维训练的过程数学和物理也有，但是你是在创造中学习，这一点会很销魂。

3. 廉价的工科实践方式：工科很多都是有创造因素的，按照人的定义，人就是能制造工具的动物，因此创作的成就感于我个人是高于去做重复劳动的。就像80后小孩儿时喜欢玩四驱车一样，创造永远是一种令人兴奋的乐趣。现在大部分工科的实践，成本都略高，比如让你去造台汽车，或者合成个有机物，一般人都没有条件去完成。但是编程，算是物美价廉的去满足你创造欲的一种方式：一个还算ok的电脑足以。

4. 代码之美：说实话，这个魅力需要你在一定时间的编程后才能体验，其感觉类似于看到数学中的美妙公式。代码是程序员写出的文字，有些代码，如同诗歌一般，令人黯然销魂.有些代码，如同杂文一般，令人拍案叫绝.有些代码，如同小说一般，令人反复回味.有些代码，如同谜语一般，令人前赴后继.有些代码，如同歌剧一般，令人如痴如狂。当你有一天面对一段代码内流满面，你就懂了我在说什么。

还有很多的原因让你爱上coding，这里不一一列举，如果说要如何爱上编程，我认为前提是擅长编程，至少熟练编程，说说我自己的经验：

1. 学会如何查找帮助：这是学习一个新语言的第一步，一般别人要我教一个语言，我一定告诉TA先学会如何用这个语言系统的帮助，这就好比学会如何用字典。每个人类语言都有字典，而且形态类似，但是计算机语言的帮助系统形态各异，比如统计语言R，是在命令行里面输入？+你要查询的内容完成，而Visual Studio大部分通过MSDN，iOS编程通过Apple Developer Center等等。因此你要先找好帮助在哪，怎么用。如果帮助看不懂，就买本入门的书籍，慢慢开始看。等你能写程序了，就会慢慢用上帮助。我自己的经验是，就算一个程序员对于一个语言系统再熟悉，写一个新的project的时候，还是有不熟悉的函数、库、接口需要查看帮助系统，因此早早学会怎么查帮助，会对你长期帮助很大。当然，实在不行，就身边找个大牛，随时请教，没有比这更靠谱的了。

2. 带着任务开始编程，起步时不必拘泥于底层原理：大部分编程教学，都是以在屏幕上输出Hello，World这个例子，其实要探究这个例子背后的实现原理，可以讲到I/O系统、编译原理、内存分配、程序入口等太多问题，但是你要做一个非系统级别的应用，这些东西都用不到，因此你开始学习时，不要太拘泥于原理，多去考虑如何编出一个想要的程序去解决你想要解决的问题比较有利于你降低学习曲线。因此很多范例式教学的编程书是很好的起步伙伴。等你熟练了，就可以考虑去深入学习一些原理性的东西，当然，完全看你的兴趣，不懂这些东西也可以写出有用的程序。

3. 找一些project做：尽力去参与一些具体的project，也许自己做不了太难的部分，可以让别人分一些简单的部分给你写。这种感觉好比你生产不了一台法拉利，但是你可以生产里面的齿轮，你看到车跑起来，也会获得很多的成就感。特别是现在面对对象（OOP）的封装思想越来越成熟后，单独完成一个部件的任务会越来越多，多去争取这种机会，你会在成就感下慢慢爱上编程。

4. 多看代码：如同前面“代码之美”里面所说，你可以多去欣赏别人的代码或者程序，把前后逻辑研究清楚，那种感觉如同：遍览千文，下笔如有神。读多了你自然就会获得很多灵感，就会懂得如何去写了。

其它知友也有很多好建议，我觉得你可以综合一下，但关键还是反复去尝试，去实践，想像你在做程序，就好比一个工匠在打磨一把日本武士刀，或者在雕琢一个玉石，其学习过程和成就感其实是类似的，你应该就会更加明白该如何前进。

赞同：374

评论：31

怎样使用 GitHub？

天猪(刘勇)

,

技术控、转战互联网、80后奶爸

--

首先你要学会git, 提供一些相关的资讯，望有帮助：

progit这本书是必看的

http://git-scm.com/book

和

http://git-scm.com/book/zh

至少阅读：第一，第二，第三，第五，共4章

，即可入门。

不过这个网站被墙了，提供下镜像吧：

progit-zh.epub

和

[中文].Pro Git.pdf

在熟悉命令行后，也许你会需要UI，那可以选择：

Downloads - msysgit - Git for Windows

http://code.google.com/p/tortoisegit/

http://www.sourcetreeapp.com/

然后建议再看看 git-flow --> 一个成功的Git分支模型

介绍：

A successful Git branching model

翻译：

http://www.juvenxu.com/2010/11/28/a-successful-git-branching-model/

工具：

nvie/gitflow · GitHub

git-flow 备忘清单

最后，你若需要本地搭建一个，那就用

GITLAB: Self Hosted Git Management Application

吧

补充一个刚发现的互动学习git的项目：

Learn Git Branching

再补充一个：

图解Git

再补充一个：

Git Magic - 前言

然后剩下github的，看官方说明吧：

https://help.github.com/

下图， 我之前对gitflow的一个翻译：

赞同：345

评论：23

如何循序渐进有效学习 JavaScript？

张克军

,

豆瓣前端工程师

我的建议：

1. 选本好书

http://book.douban.com/subject/2994925/

http://book.douban.com/subject/4886879/

2. 阅读源码

https://github.com/languages/JavaScript

3. 实践、实践、再实践

4. 关注行业动态，参与开源社区

这几个blog至少要订阅：

http://www.nczonline.net/blog/

http://javascriptweblog.wordpress.com/

http://dailyjs.com/

http://functionsource.com/

http://www.reddit.com/r/javascript/

赞同：338

评论：18

为什么很多国内公司不使用 jQuery 等开源 JS 框架（库），而选择自己开发 JavaScript 框架？

玉伯

,

因上努力，果上随缘。

折腾过 KISSY 类库，简单说几点：

1. 开发 KISSY 之前，淘宝使用的是 YUI2 类库。但从 2009 年开始，YUI2 在逐步退出历史舞台，YUI 团队的大部分精力都投入到 YUI3 的开发中去了。从当时的情况来看，YUI2 前途堪忧，YUI3 则还不够成熟，并且 YUI3 的定位（大而全的框架型类库）不适合淘宝的前台业务场景（以浏览型为主的展现页面）。

2. 我自己是力推 jQuery 的。但由于历史原因，阿里系对 jQuery 的成见很深，认为其接口太灵活，不利于团队协作，以及其插件质量良莠不齐，社区不如 YUI 健壮。2008 年在淘宝前端内部争辩过 jQuery，可惜我没坚持，没推广成功。

3. 但当时不少新人都喜欢 jQuery 的 API 风格，jQuery 社区也发展得越来越好。我自己也是个铁杆 jQuery API fans. 因为前两点原因，2009 年在开发 KISSY Editor 时，底层虽然是基于 YUI2 的，但我逐步已经做了很多替换封装，实现了一个简易的杂糅了 YUI2 和 jQuery API 风格的底层类库，这就是 KISSY 的原型。

4. 接下来是技术驱动的一段时期，2010 年基于 KISSY core 写了 Switchable、Suggest 等在淘宝被大量使用的 UI 组件，一下来就推广开来了。（中间 YUI2 和 KISSY 并存了很长时间）

5. KISSY 进一步发展，得益于核心开发成员承玉的加盟。2011 年后，KISSY 从 KISS 的定位，逐步演化成了立足于淘宝、力争大而全、同时可定制的一个类库。承玉做的非常不错，还有龙藏的 Flash 组件等，以及仿 YUI3 Gallery 的组件贡献模式，这些让 KISSY 成为了适合淘宝业务的最佳类库。

上面说了这么多，总结下与楼主的问题相关的几点：

1. 选择什么类库，抑或自己开发，

跟团队的技能倾向有关。

如果雅虎和阿里没关系，或许阿里就不会这么雅虎味，或许也就不会对 jQuery 有成见，或许现在压根儿就没 KISSY 什么事。

2.

类库的选择离不开业务场景

。如果淘宝不是浏览型为主的网站，而是个个页面都像 GMail 一样复杂，那也许淘宝选择的类库会是 ExtJS 或 Google Closure 或 YUI3 等等。其实淘宝的后台项目中，还真有不少是用 ExtJS 的。

3.

对于商业公司来说，类库的重点不是基础模块，而是业务模块

。这里的业务模块包括淘宝的登录注册等模块，也包括 Switchable、Suggest 等泛业务模块（比如淘宝首页的搜索提示，看似是通用的，其实是跟淘宝的业务类型分不开的。YUI2 也有一个 Autocomplete 组件，但其庞大的体积根本不适应淘宝）。

4. 类库的选择，还

跟整个业界的环境和团队决策者的眼光相关

。比如从去年开始，前端社区越来越意识到了开放共荣的重要性，意识到了规范的重要性。CommonJS、AMD 等等，以及 NodeJS 的兴起，这一切变化，也在悄然改变着大家的抉择。这是我开发 SeaJS 的原因。如今，我们有了更好的、更偷懒、同时更灵活的选择和组合解决方案。

任何路都没什么错，关键是，要知道自己在哪。

赞同：288

评论：20

知乎工程师们的开发环境是怎么样的？

高昌健

,

知乎海盗船员

之前昆哥在

http://www.zhihu.com/question/19755412/answer/12868016

有简要提到一些，我这里详细补充下。

生产环境

由于网速的原因，知乎没有选用 AWS 这样的平台，而是租用的国内机房，BGP 线路。

机器的操作系统都是 Debian，我们为每一台机器取了名字，源自「海贼王」里的各个角色名。下面是部分机器截图，你们能猜到每一台分别是干嘛的吗？

每次部署上线的时候都会有我们勤劳的 zhihu.bot 机器人提醒大家，可惜目前为止还不能跟它聊天。

开发环境

知乎为每个工程师配备了 13 寸高配 MacBook Pro，23 寸戴尔显示器，以及人体工学座椅。很多工程师自配了机械键盘，于是每天工作的时候你会听到周围一阵阵清脆的键盘声传来（作为 MBP 键盘党表示深受其害）。实习生通常是 iMac 或者 Mac mini。这是我的工位照片：

为了保证开发环境和生产环境的一致性，受 Vagrant [1] 启发，我们开发了一个基于 VirtualBox 的工具：Hobox，具有与生产环境一样的 Debian 系统，Python 环境，服务配置等。

平时的工作系统是 OS X（其实娱乐系统也是⋯），后端团队用 Vim 居多，前端团队用 Sublime Text、TextMate、Vim，搜索团队用 IntelliJ IDEA、Vim 等，运维团队用 Vim 和 Emacs，iOS 团队当然是用 Xcode 啦。

版本控制系统是 Git，代码大部分托管在 GitHub 上，还有些在 Bitbucket，小项目也放在内网的 GitLab 上。

我们现在统一使用 Phabricator [2] 来进行 code review，bug tracking，任务管理和知识整理。

我们使用 Buildout [3] 作为构建系统，同时搭建了私有的 PyPI 源。

除了工作⋯

知乎提供免费午餐，免费零食，免费水果，免费饮料，免费见各种名人的机会。

每周会有一次分享，技术或者产品都有。

每周会有一次体育活动，篮球、羽毛球、游泳任选。

众多 DotA、CS 高手可以切磋技艺，还有魔方高手，乐高机器人高手，重口味文艺青年若干。

------

[1] Vagrant:

http://vagrantup.com

[2] Phabricator:

http://phabricator.org

[3] Buildout:

http://www.buildout.org

赞同：287

评论：61

怎么把知乎收藏夹下载下来做成电子书在手机上看？

姚泽源

,

被Unicode编码问题给气坏了= =

谢邀，终于可以回答这个问题了。

用

2014年5月8日.zip_免费高速下载

，自动生成Epub格式的电子书，Windows用户双击运行，Mac/Linux用户参考这里的回答

如何保存某位知乎用户的所有答案？

私以为此题可以重定向了~嘿嘿

赞同：283

评论：61

微信扫描二维码登录网页是什么原理，前后两个事件是如何联系的？

黄良懿

,

做做架构，写写代码

反对

@朱立雄

的答案，从回答可以看得出来他对技术细节并不了解。对前端开发有了解的同学随便开个 Firebug 看看登录过程的 Net 视图基本就能大概看清楚这个过程。

我个人开发过程一般是和产品说，『你们提业务要求、交互方式、性能要求等就好，技术方案我们会综合开发时间、系统架构等因素考虑』。

恰好我之前也花过几个小时做过类似的验证登录过程，这里作为探讨，把产品同学的回答做个引用，解释一下其中『不技术』的地方。

1. 每打开一次

微信网页版

页面的时候会随机生成一个含有唯一uid的二维码，每次刷新页面都会不一样（这个可以保证一个uid只可以绑定一个账号和密码，如果一个uid可以绑定多个账号和密码，那么很可能你的电脑会登陆别人的微信哦）.

确实返回了唯一 id，但目的是为了识别用户身份，而且实际上打开这个页面的时候浏览器已经和 Server 创建了一个长连接等待确认信息。

查看

http://wx.qq.com

的源码可以看到，这个页面在加载完毕时，也已经把很多登录后才需要的相关资源都预先加载进来了，所以长连接等待登录用户得到确认后展示用户信息的速度很快，因为无需刷页面和加载头像外的其他资源。

2. 当用户使用登陆后的微信扫描该二维码的时候，会将这个id和手机上的微信账号及密码绑定，并上传到

微信网页版

服务器.

先上个图：

二维码样例：

http://weixin.qq.com/x/ARmFYVvUzczwBl9u6Y1I

，利用我查查之类的二维码应用可以得到类似这样的地址，但并不会自动打开该地址，微信客户端针对

http://weixin.qq.com/x/

开头的地址做了特殊处理，会自动获取相关信息并提示确认。 在手机版微信访问这个页面进行确认时，Server已经同时获得了客户端信息，并通过之前保持的长连接告知浏览器。

3.

微信网页版

页面每隔1秒或2秒会get请求该id对应的微信账号及密码，如果id绑定上了微信账号和密码，那么就可以请求到账号和密码，就可以自动登陆了。

浏览器展示完长连接里包含的用户信息（头像等）后，会新开一个长连接等待客户端的确认操作，其 URL 类似

https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?uuid=794ecedd804f47&tip=1&_=1395748413642

。从安全的角度来说，无论如何都不会让客户端获得微信帐号和密码的。要知道，密码这玩意腾讯自己都不敢保存（有兴趣的同学可以自行了解下 CSDN 明文密码泄露事件），肯定是不可能返回给浏览器的。

而且从体感来看，怎么着都不可能是页面1-2秒轮询发起GET请求的，实际是通过堵塞等待的长连接，近乎实时的获得信息。 对于验证过程，Open API 一般是通过授权令牌（Token）来解决的，原理是当用户通过授权后，分配一个限定条件下的令牌（如限制本机访问、限制授权有效时间、限制同时登录设备数等），使获得授权的用户仅在有限的前提下能访问相关服务。 像计算机休眠后曾做的授权就自动收回了，这样就有效的避免了在别人电脑上（尤其是网吧）打开，但忘记关闭或退出这类安全问题了。

同时，整个授权过程的验证部分在手机端进行，有效杜绝了 PC 上泛滥的各类木马、『安全工具』的监听，大大降低了帐号被盗的风险。

所以说，核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。 并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。 在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。

赞同：279

评论：27

机器学习该怎么入门？

吴俣

,

北航微软联合培养博士生

我要翻译一把quora了，再加点我的理解，我相信会是一个好答案，链接我都放到一起了，没插入到正文中，要求其实比较高了，我觉得我自己都差很远很远~~~我尽量持续更新翻译质量以及自己理解

1.

Python/C++/R/Java

- you will probably want to learn all of these languages at some point if you want a job in machine-learning. Python's Numpy and Scipy libraries [2] are awesome because they have similar functionality to MATLAB, but can be easily integrated into a web service and also used in Hadoop (see below). C++ will be needed to speed code up. R [3] is great for statistics and plots, and Hadoop [4] is written in Java, so you may need to implement mappers and reducers in Java (although you could use a scripting language via Hadoop streaming [5])

首先，你要熟悉这四种语言。Python因为开源的库比较多，可以看看Numpy和Scipy这两个库，这两个都可以很好的融入网站开发以及Hadoop。C++可以让你的代码跑的更快，R则是一个很好地统计工具。而你想很好地使用Hadoop你也必须懂得java，以及如何实现map reduce

2.

Probability and Statistics

: A good portion of learning algorithms are based on this theory. Naive Bayes [6], Gaussian Mixture Models [7], Hidden Markov Models [8], to name a few. You need to have a firm understanding of Probability and Stats to understand these models. Go nuts and study measure theory [9]. Use statistics as an model evaluation metric: confusion matrices, receiver-operator curves, p-values, etc.

我推荐统计学习方法 李航写的，这算的上我mentor的mentor了。理解一些概率的理论，比如贝叶斯，SVM，CRF，HMM，决策树，AdaBoost，逻辑斯蒂回归，然后再稍微看看怎么做evaluation 比如P R F。也可以再看看假设检验的一些东西。

3.

Applied Math + Algorithms

: For discriminate models like SVMs [10], you need to have a firm understanding of algorithm theory. Even though you will probably never need to implement an SVM from scratch, it helps to understand how the algorithm works. You will need to understand subjects like convex optimization [11], gradient decent [12], quadratic programming [13], lagrange [14], partial differential equations [15], etc. Get used to looking at summations [16].

机器学习毕竟是需要极强极强数学基础的。我希望开始可以深入的了解一些算法的本质，SVM是个很好的下手点。可以从此入手，看看拉格朗日，凸优化都是些什么

4.

Distributed Computing

: Most machine learning jobs require working with large data sets these days (see Data Science) [17]. You cannot process this data on a single machine, you will have to distribute it across an entire cluster. Projects like Apache Hadoop [4] and cloud services like Amazon's EC2 [18] makes this very easy and cost-effective. Although Hadoop abstracts away a lot of the hard-core, distributed computing problems, you still need to have a firm understanding of map-reduce [22], distribute-file systems [19], etc. You will most likely want to check out Apache Mahout [20] and Apache Whirr [21].

熟悉分布计算，机器学习当今必须是多台机器跑大数据，要不然没啥意义。请熟悉Hadoop，这对找工作有很大很大的意义。百度等公司都需要hadoop基础。

5.

Expertise in Unix Tools

: Unless you are very fortunate, you are going to need to modify the format of your data sets so they can be loaded into R,Hadoop,HBase [23],etc. You can use a scripting language like python (using re) to do this but the best approach is probably just master all of the awesome unix tools that were designed for this: cat [24], grep [25], find [26], awk [27], sed [28], sort [29], cut [30], tr [31], and many more. Since all of the processing will most likely be on linux-based machine (Hadoop doesnt run on Window I believe), you will have access to these tools. You should learn to love them and use them as much as possible. They certainly have made my life a lot easier. A great example can be found here [1].

熟悉Unix的Tool以及命令。百度等公司都是依靠Linux工作的，可能现在依靠Windows的Service公司已经比较少了。所以怎么也要熟悉Unix操作系统的这些指令吧。我记得有个百度的面试题就是问文件复制的事情。

6.

Become familiar with the Hadoop sub-projects

: HBase, Zookeeper [32], Hive [33], Mahout, etc. These projects can help you store/access your data, and they scale.

机器学习终究和大数据息息相关，所以Hadoop的子项目要关注，比如HBase Zookeeper Hive等等

7.

Learn about advanced signal processing techniques

: feature extraction is one of the most important parts of machine-learning. If your features suck, no matter which algorithm you choose, your going to see horrible performance. Depending on the type of problem you are trying to solve, you may be able to utilize really cool advance signal processing algorithms like: wavelets [42], shearlets [43], curvelets [44], contourlets [45], bandlets [46]. Learn about time-frequency analysis [47], and try to apply it to your problems. If you have not read about Fourier Analysis[48] and Convolution[49], you will need to learn about this stuff too. The ladder is signal processing 101 stuff though.

这里主要是在讲特征的提取问题。无论是分类（classification）还是回归（regression）问题，都要解决特征选择和抽取（extraction）的问题。他给出了一些基础的特征抽取的工具如小波等，同时说需要掌握傅里叶分析和卷积等等。这部分我不大了解，大概就是说信号处理你要懂，比如傅里叶这些。。。

Finally, practice and read as much as you can. In your free time, read papers like Google Map-Reduce [34], Google File System [35], Google Big Table [36], The Unreasonable Effectiveness of Data [37],etc There are great free machine learning books online and you should read those also. [38][39][40]. Here is an awesome course I found and re-posted on github [41]. Instead of using open source packages, code up your own, and compare the results. If you can code an SVM from scratch, you will understand the concept of support vectors, gamma, cost, hyperplanes, etc. It's easy to just load some data up and start training, the hard part is making sense of it all.

总之机器学习如果想要入门分为两方面：

一方面是去看算法，需要极强的数理基础（真的是极强的），从SVM入手，一点点理解。

另一方面是学工具，比如分布式的一些工具以及Unix~

Good luck.

祝好

[1]

http://radar.oreilly.com/2011/04...

[2]

NumPy — Numpy

[3]

The R Project for Statistical Computing

[4]

Welcome to Apache™ Hadoop®!

[5]

http://hadoop.apache.org/common/...

[6]

http://en.wikipedia.org/wiki/Nai...

[7]

http://en.wikipedia.org/wiki/Mix...

[8]

http://en.wikipedia.org/wiki/Hid...

[9]

http://en.wikipedia.org/wiki/Mea...

[10]

http://en.wikipedia.org/wiki/Sup...

[11]

http://en.wikipedia.org/wiki/Con...

[12]

http://en.wikipedia.org/wiki/Gra...

[13]

http://en.wikipedia.org/wiki/Qua...

[14]

http://en.wikipedia.org/wiki/Lag...

[15]

http://en.wikipedia.org/wiki/Par...

[16]

http://en.wikipedia.org/wiki/Sum...

[17]

http://radar.oreilly.com/2010/06...

[18]

AWS | Amazon Elastic Compute Cloud (EC2)

[19]

http://en.wikipedia.org/wiki/Goo...

[20]

Apache Mahout: Scalable machine learning and data mining

[21]

http://incubator.apache.org/whirr/

[22]

http://en.wikipedia.org/wiki/Map...

[23]

HBase - Apache HBase Home

[24]

http://en.wikipedia.org/wiki/Cat...

[25]

grep

[26]

http://en.wikipedia.org/wiki/Find

[27]

AWK

[28]

sed

[29]

http://en.wikipedia.org/wiki/Sor...

[30]

http://en.wikipedia.org/wiki/Cut...

[31]

http://en.wikipedia.org/wiki/Tr_...

[32]

Apache ZooKeeper

[33]

Apache Hive TM

[34]

http://static.googleusercontent....

[35]

http://static.googleusercontent....

[36]

http://static.googleusercontent....

[37]

http://static.googleusercontent....

[38]

http://www.ics.uci.edu/~welling/...

[39]

http://www.stanford.edu/~hastie/...

[40]

http://infolab.stanford.edu/~ull...

[41]

https://github.com/josephmisiti/...

[42]

http://en.wikipedia.org/wiki/Wav...

[43]

http://www.shearlet.uni-osnabrue...

[44]

http://math.mit.edu/icg/papers/F...

[45]

http://www.ifp.illinois.edu/~min...

[46]

http://www.cmap.polytechnique.fr...

[47 ]

http://en.wikipedia.org/wiki/Tim...

[48]

http://en.wikipedia.org/wiki/Fou...

[49 ]

http://en.wikipedia.org/wiki/Con...

赞同：267

评论：10